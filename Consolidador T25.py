# -*- coding: utf-8 -*-
"""CONSOLIDADOR T25 COMPLETO.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18uGYuf9ZAghW8hbaSU84ATHI-EmsMdiB
"""

# -*- coding: utf-8 -*-
"""Consolidador T25 Version 9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XshVjm7lal9-jHzcCH12BxJbVPFZJBeo
"""

# -*- coding: utf-8 -*-
"""Consolidador T25 Version 8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1won1RYLfr5dii6IbnZrZQKu5cIan2yHp
"""

# -*- coding: utf-8 -*-
"""CONSOLIDADOR T25 Version 8 - v15.1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eUFunnp-PjlTxVdnHmcUmftvNLFL1Bdr
"""

# -*- coding: utf-8 -*-
"""
CONSOLIDADOR T25 v15.1 - CÃ“DIGO COMPLETO CON CORRECCIONES

CORRECCIONES v15.1 (NUEVAS):
1. EXCLUSIÃ“N "ANALISIS DE TARIFAS": Archivos con "ANALISIS DE TARIFAS" o variantes NO se procesan
   - Excluye: ANALISIS DE TARIFAS, ANÃLISIS DE TARIFA, ANALISIS TARIFAS, etc.
   - Procesa: TARIFAS (sola), TARIFA (sola), 335-TARIFAS-CLINICA, etc.

CORRECCIONES v15.0 (ANTERIORES):
1. DETECCIÃ“N MEJORADA DE ARCHIVOS: Detecta archivos con formato "NNN-TARIFAS-PROVEEDOR"
2. OTROSÃ EXPANDIDO: Detecta OTROSI_1, OTROSI#1, OT_1, ADICION_1, etc.
3. NUEVA FUNCIÃ“N es_archivo_tarifas_valido(): ClasificaciÃ³n completa de archivos
4. NUEVA FUNCIÃ“N clasificar_tipo_archivo(): Retorna info detallada del archivo
5. ALERTA FORMATO_PROPIO: Cuando las hojas son muy diferentes al estÃ¡ndar POSITIVA

PATRONES DE ARCHIVOS DETECTADOS v15.0:
- NNN-TARIFAS-PROVEEDOR-NIT.ext (ej: 335-TARIFAS-CLINICA_SOMEDA_SAS-825001800.xlsx)
- TARIFAS-PROVEEDOR-NIT.ext (ej: TARIFAS-ESE_HOSPITAL_SAN_JOSE-832001966.xlsx)
- OTROSI_N-TARIFAS-... (ej: OTROSI_1-TARIFAS-189-2019-DIAXME_SAS.xlsx)
- OTROSI#N-TARIFAS-... (ej: OTROSI#2-TARIFAS-329-MEDINUCLEAR.xlsb)
- ANEXO_1-... (formato tradicional)

CORRECCIONES ANTERIORES (v14.1):
1. ALERTA DE PAQUETES: Solo cuando NO existe hoja de servicios
2. TELÃ‰FONOS: ValidaciÃ³n SIN guiones (como vienen en Excel)
3. ValidaciÃ³n de CUPS ultra estricta - rechaza ciudades y valores monetarios
4. DetecciÃ³n de secciones de traslados para evitar mapeo incorrecto
5. Alertas de ambulancias con categorÃ­a "cuentas mÃ©dicas Ambulancias"
6. Sistema de alertas sin duplicados mejorado
7. Muestra hojas disponibles cuando no encuentra hoja de servicios
8. DetecciÃ³n de formato propio (no POSITIVA estÃ¡ndar)
9. Hospital Pablo Tobon Uribe: procesa TODOS los anexos
"""

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LISTA COMPLETA DE CIUDADES COLOMBIANAS (para validaciÃ³n de CUPS)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CIUDADES_COLOMBIA_COMPLETA = {
    # Capitales
    'BOGOTÃ', 'BOGOTA', 'MEDELLÃN', 'MEDELLIN', 'CALI', 'BARRANQUILLA',
    'CARTAGENA', 'BUCARAMANGA', 'CÃšCUTA', 'CUCUTA', 'PEREIRA', 'IBAGUÃ‰',
    'IBAGUE', 'SANTA MARTA', 'MANIZALES', 'VILLAVICENCIO', 'PASTO',
    'MONTERÃA', 'MONTERIA', 'NEIVA', 'ARMENIA', 'SINCELEJO', 'POPAYÃN',
    'POPAYAN', 'VALLEDUPAR', 'TUNJA', 'FLORENCIA', 'QUIBDÃ“', 'QUIBDO',
    'RIOHACHA', 'YOPAL', 'MOCOA', 'LETICIA', 'INÃRIDA', 'INIRIDA',
    'MITÃš', 'MITU', 'PUERTO CARREÃ‘O', 'SAN JOSÃ‰ DEL GUAVIARE', 'ARAUCA',
    # Ciudades intermedias usadas en traslados
    'BAHIA SOLANO', 'BARRANCABERMEJA', 'BUENAVENTURA', 'PALMIRA',
    'CARTAGO', 'TULUA', 'TULUÃ', 'BUGA', 'SOGAMOSO', 'DUITAMA', 'GIRARDOT',
    'FUSAGASUGA', 'FUSAGASUGÃ', 'FACATATIVA', 'FACATATIVÃ', 'ZIPAQUIRA',
    'ZIPAQUIRÃ', 'CHIA', 'CHÃA', 'SOACHA', 'RIONEGRO', 'ENVIGADO',
    'ITAGUI', 'ITAGÃœÃ', 'BELLO', 'TUMACO', 'IPIALES', 'GRANADA', 'ACACIAS',
    'ACACÃAS', 'PUERTO LOPEZ', 'PUERTO LÃ“PEZ', 'AGUACHICA', 'OCAÃ‘A',
    'APARTADO', 'APARTADÃ“', 'TURBO', 'CAUCASIA', 'MAGANGUE', 'MAGANGUÃ‰',
    'LORICA', 'CERETE', 'CERETÃ‰', 'ESPINAL', 'MELGAR', 'FLANDES', 'HONDA',
    'MARIQUITA', 'LA DORADA', 'PUERTO BERRIO', 'PUERTO BERRÃO',
    'PUERTO BOYACA', 'PUERTO BOYACÃ', 'CIENAGA', 'CIÃ‰NAGA', 'FUNDACION',
    'FUNDACIÃ“N', 'ARACATACA', 'EL BANCO', 'PLATO', 'COROZAL', 'SAMPUES',
    'SAMPUÃ‰S', 'SAN MARCOS', 'ZARZAL', 'JAMUNDI', 'JAMUNDÃ', 'YUMBO',
    'CANDELARIA', 'PRADERA', 'FLORIDA', 'CERRITO', 'GUACARI', 'GUACARÃ',
    'GINEBRA', 'ROLDANILLO', 'LA UNION', 'LA UNIÃ“N', 'SEVILLA',
    'CAICEDONIA', 'ARGELIA', 'DARIEN', 'DARIÃ‰N', 'RESTREPO', 'DAGUA',
    'LA CUMBRE', 'CLO', 'BOG', 'MDE',  # CÃ³digos de aeropuerto
}

DEPARTAMENTOS_COLOMBIA = {
    'BOGOTÃ D.C', 'BOGOTA D.C', 'BOGOTÃ D.C.', 'BOGOTA D.C.',
    'ANTIOQUIA', 'ATLÃNTICO', 'ATLANTICO', 'BOLÃVAR', 'BOLIVAR',
    'BOYACÃ', 'BOYACA', 'CALDAS', 'CAQUETÃ', 'CAQUETA', 'CASANARE',
    'CAUCA', 'CESAR', 'CHOCÃ“', 'CHOCO', 'CÃ“RDOBA', 'CORDOBA',
    'CUNDINAMARCA', 'GUAINÃA', 'GUAINIA', 'GUAVIARE', 'HUILA',
    'LA GUAJIRA', 'MAGDALENA', 'META', 'NARIÃ‘O', 'NARINO',
    'NORTE DE SANTANDER', 'PUTUMAYO', 'QUINDÃO', 'QUINDIO',
    'RISARALDA', 'SAN ANDRÃ‰S', 'SAN ANDRES', 'SANTANDER', 'SUCRE',
    'TOLIMA', 'VALLE', 'VALLE DEL CAUCA', 'VAUPÃ‰S', 'VAUPES',
    'VICHADA', 'AMAZONAS', 'ARAUCA'
}

MUNICIPIOS_COLOMBIA = CIUDADES_COLOMBIA_COMPLETA | DEPARTAMENTOS_COLOMBIA

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PREFIJOS DE CELULAR COLOMBIANO (para validaciÃ³n de telÃ©fonos)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PREFIJOS_CELULAR_COLOMBIA = {
    '300', '301', '302', '303', '304', '305',
    '310', '311', '312', '313', '314', '315', '316', '317', '318',
    '320', '321', '322', '323', '324',
    '350', '351',
    '330', '331', '332', '333'
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# HOJAS A EXCLUIR (silenciosamente, sin alerta)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

HOJAS_EXCLUIR_SILENCIOSAMENTE = {
    'INSTRUCCIONES', 'INFO', 'DATOS', 'CONTENIDO', 'INDICE', 'ÃNDICE',
    'GUIA DE USO', 'GUÃA DE USO', 'CONTROL DE CAMBIOS', 'HOJA1', 'SHEET1',
    'INSTRUCTIVO', 'PARAMETROS', 'PARÃMETROS', 'CONFIGURACION', 'CONFIGURACIÃ“N',
    'LISTA', 'LISTAS', 'VALIDACION', 'VALIDACIÃ“N', 'CATALOGO', 'CATÃLOGO',
    'RESUMEN', 'PORTADA', 'CARATULA', 'CARÃTULA', 'INICIO', 'HOME',
    'MENU', 'MENÃš', 'ANEXO TECNICO', 'ANEXO TÃ‰CNICO', 'GLOSARIO',
}

# Hojas que NO generan alerta individualmente, pero se mencionan
# si no hay hoja de servicios vÃ¡lida
HOJAS_SIN_SERVICIOS_VALIDOS = {
    'PAQUETES', 'TARIFAS PAQUETES', 'PAQUETE',
    'COSTO VIAJE', 'COSTO DE VIAJE', 'COSTOS VIAJE',
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PALABRAS INVÃLIDAS PARA CUPS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PALABRAS_INVALIDAS_CUPS = [
    'CODIGO', 'CUPS', 'ITEM', 'DESCRIPCION', 'TARIFA', 'TOTAL', 'SUBTOTAL',
    'DEPARTAMENTO', 'MUNICIPIO', 'HABILITACION', 'HABIITACION', 'DIRECCION',
    'TELEFONO', 'EMAIL', 'SEDE', 'NOMBRE', 'NUMERO', 'ESPECIALIDAD',
    'MANUAL', 'OBSERV', 'PORCENTAJE', 'HOMOLOGO', 'NÂ°', 'NO.',
    'NOTA', 'NOTAS', 'ACLARATORIA', 'ACLARATORIAS', 'ACLARACION', 'ACLARACIONES',
    'INCLUYE', 'NO INCLUYE', 'EXCLUYE',
    'USO DE EQUIPO', 'DERECHO DE SALA', 'DERECHO SALA',
    'VER NOTA', 'VER NOTAS', 'SEGUN NOTA',
    'APLICA', 'NO APLICA', 'SEGÃšN', 'SEGUN',
    'CONSULTAR', 'REVISAR', 'PENDIENTE',
    'VALOR', 'PRECIO', 'COSTO',
    'CONTRATO', 'ACTA', 'OTROSI', 'OTROSÃ',
    'VIGENTE', 'VIGENCIA',
    'TRASLADO', 'ORIGEN', 'DESTINO',
    'TARIFAS PROPIAS', 'TARIFA PROPIA',
]

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIONES DE DETECCIÃ“N DE ARCHIVOS v15.0
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import re

def es_archivo_tarifas_valido(nombre: str) -> tuple:
    """
    ğŸ†• v15.1: Detecta si un archivo es vÃ¡lido para procesamiento de tarifas.

    PATRONES VÃLIDOS:
    1. Contiene "ANEXO 1" o "ANEXO_1" (formato tradicional)
    2. Contiene "TARIFAS" o "TARIFA" en el nombre (formato simplificado)
    3. Contiene "OTROSI" o "OTROSÃ" seguido de nÃºmero

    EXCLUSIONES v15.1:
    - "ANALISIS DE TARIFAS" y variantes (ANÃLISIS, sin DE, singular/plural)

    Retorna: (es_valido: bool, tipo: str)
    Tipos: 'ANEXO_1', 'TARIFAS', 'OTROSI', 'INVALIDO'
    """
    if not nombre:
        return False, 'INVALIDO'

    nombre_upper = nombre.upper()

    # EXCLUSIONES: archivos que NO se deben procesar
    palabras_excluir = [
        'MEDICAMENT', 'MEDICAMENTO', 'MEDICAMENTOS',
        'FARMACO', 'FÃRMACO', 'FARMACOS', 'FÃRMACOS',
        'INSUMO', 'INSUMOS'
    ]

    for palabra in palabras_excluir:
        if palabra in nombre_upper:
            if 'SERVICIO' in nombre_upper or 'SERV' in nombre_upper:
                continue
            return False, 'INVALIDO'

    # ğŸ†• v15.1: EXCLUSIÃ“N: "ANALISIS DE TARIFAS" y variantes NO se procesan
    # Pero "TARIFAS" o "TARIFA" solas SÃ se procesan
    if re.search(r'AN[AÃ]LISIS\s*(DE\s*)?(TARIFAS?|TARIFA)', nombre_upper):
        return False, 'INVALIDO'

    # DETECCIÃ“N 1: Archivos OTROSÃ (tienen prioridad)
    patrones_otrosi = [
        r'OTRO\s*S[IÃ]\s*[_#\-\s]*(\d+)',
        r'OTROS[IÃ]\s*[_#\-\s]*(\d+)',
        r'OT[_\-\s]?(\d+)',
        r'ADICI[OÃ“]N\s*[_#\-\s]*(\d+)',
        r'MODIFICACI[OÃ“]N\s*[_#\-\s]*(\d+)',
    ]

    for patron in patrones_otrosi:
        if re.search(patron, nombre_upper):
            return True, 'OTROSI'

    # DETECCIÃ“N 2: Archivos con ANEXO 1 explÃ­cito
    patrones_anexo1 = [
        r'ANEXO\s*[_\-\s]*0?1(?!\d)',
        r'ANEX[O0]\s*[_\-\s]*1(?!\d)',
        r'ANEXO\s*N[OÃšÂºÂ°]?\.?\s*0?1(?!\d)',
        r'A1[_\-\s]',
        r'[_\-]ANEXO[_\-]?1',
        r'ANEXO[_\-]1[_\-]',
    ]

    for patron in patrones_anexo1:
        if re.search(patron, nombre_upper):
            return True, 'ANEXO_1'

    n_limpio = nombre_upper.replace(' ', '').replace('_', '').replace('-', '').replace('(', '').replace(')', '')
    if 'ANEXO1' in n_limpio or 'ANEXO01' in n_limpio:
        return True, 'ANEXO_1'

    # EXCLUSIÃ“N: Verificar si es ANEXO 2, 3, etc.
    patron_anexo_no_1 = r'ANEXO\s*[_\-\s]*([2-9]|[1-9]\d)(?!\d)'
    if re.search(patron_anexo_no_1, nombre_upper):
        return False, 'INVALIDO'

    # DETECCIÃ“N 3: Archivos que contienen "TARIFAS" (formato simplificado)
    patrones_tarifas = [
        r'\d+[\-_]TARIFAS[\-_]',
        r'^TARIFAS[\-_]',
        r'[\-_]TARIFAS[\-_]',
        r'[\-_]TARIFAS\.',
    ]

    for patron in patrones_tarifas:
        if re.search(patron, nombre_upper):
            return True, 'TARIFAS'

    # DETECCIÃ“N 4: Combinaciones especiales
    if 'ANEXO' in nombre_upper and ('TARIFA' in nombre_upper or 'SERV' in nombre_upper):
        otros_anexos = re.search(r'ANEXO\s*[_\-\s]*([2-9]|[1-9]\d)(?!\d)', nombre_upper)
        if not otros_anexos:
            return True, 'ANEXO_1'

    return False, 'INVALIDO'


def contiene_anexo1(nombre: str) -> bool:
    """
    ğŸ†• v15.0: Detecta si el nombre corresponde a un archivo procesable de tarifas.

    AHORA INCLUYE:
    - Archivos con ANEXO 1 explÃ­cito
    - Archivos con "TARIFAS" en el nombre (formato simplificado)
    - Archivos de OTROSÃ
    """
    es_valido, tipo = es_archivo_tarifas_valido(nombre)
    return es_valido


def extraer_numero_otrosi_global(nombre: str):
    """
    ğŸ†• v15.0: Extrae el nÃºmero de otrosÃ­ del nombre del archivo.
    """
    if not nombre:
        return None

    nombre_upper = nombre.upper()

    patrones = [
        r'OTRO\s*S[IÃ]\s*[_#\-\s]*N?[OÃšÂºÂ°]?\.?\s*(\d+)',
        r'OTROS[IÃ]\s*[_#\-\s]*(\d+)',
        r'OTRO[\s_\-]?SI[\s_\-#]*(\d+)',
        r'OT\s*[_\-\s]?\s*(\d+)',
        r'ADICI[OÃ“]N\s*[_#\-\s]*N?[OÃšÂºÂ°]?\.?\s*(\d+)',
        r'MODIFICA(?:CI[OÃ“]N)?\s*[_#\-\s]*(\d+)',
    ]

    for patron in patrones:
        match = re.search(patron, nombre_upper)
        if match:
            try:
                return int(match.group(1))
            except (ValueError, IndexError):
                continue

    return None


def clasificar_tipo_archivo(nombre: str) -> dict:
    """
    ğŸ†• v15.0: Clasifica un archivo y retorna informaciÃ³n completa.
    """
    resultado = {
        'es_valido': False,
        'tipo': 'INVALIDO',
        'numero_otrosi': None,
        'es_otrosi': False,
        'motivo_exclusion': None
    }

    if not nombre:
        resultado['motivo_exclusion'] = 'Nombre vacÃ­o'
        return resultado

    nombre_upper = nombre.upper()

    palabras_excluir = ['MEDICAMENT', 'FARMACO', 'FÃRMACO', 'INSUMO']
    for palabra in palabras_excluir:
        if palabra in nombre_upper:
            if 'SERVICIO' not in nombre_upper and 'SERV' not in nombre_upper:
                resultado['motivo_exclusion'] = f'Archivo de {palabra.lower()}'
                return resultado

    num_otrosi = extraer_numero_otrosi_global(nombre)
    if num_otrosi:
        resultado['numero_otrosi'] = num_otrosi
        resultado['es_otrosi'] = True

    es_valido, tipo = es_archivo_tarifas_valido(nombre)
    resultado['es_valido'] = es_valido
    resultado['tipo'] = tipo

    if not es_valido:
        resultado['motivo_exclusion'] = 'No coincide con patrones de tarifas'

    return resultado


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIÃ“N: es_telefono_celular_colombiano
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def es_telefono_celular_colombiano(valor: str) -> bool:
    """
    v14.1: Detecta si un valor es un telÃ©fono celular colombiano.
    CORREGIDO: Funciona con nÃºmeros SIN guiones (como vienen en Excel).

    Ejemplos que detecta:
    - 3214567890 (sin guiones)
    - 3001234567
    - 3501234567

    NO debe confundir con:
    - Tarifas (5920000, 11380000)
    - CÃ³digos CUPS (890201)
    - HabilitaciÃ³n (7614708225)
    """
    if not valor:
        return False

    import re

    # Limpiar el valor - quitar TODO excepto dÃ­gitos
    valor_str = str(valor).strip()

    # Si termina en .0, quitarlo
    if valor_str.endswith('.0'):
        valor_str = valor_str[:-2]

    # Quitar cualquier caracter no dÃ­gito
    valor_clean = re.sub(r'[^\d]', '', valor_str)

    # Debe ser exactamente 10 dÃ­gitos
    if len(valor_clean) != 10:
        return False

    # Verificar prefijo de celular colombiano
    prefijo = valor_clean[:3]
    return prefijo in PREFIJOS_CELULAR_COLOMBIA


def es_telefono_celular(valor: str) -> bool:
    """Alias para compatibilidad."""
    return es_telefono_celular_colombiano(valor)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIÃ“N: validar_cups
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def validar_cups(cups: str, fila: list = None) -> bool:
    """
    v14.1: ValidaciÃ³n de CUPS ULTRA estricta.

    RECHAZA:
    - Ciudades colombianas (ARMENIA, CALI, BAHIA SOLANO, etc.)
    - Valores monetarios grandes (>= 7 dÃ­gitos)
    - TelÃ©fonos celulares (10 dÃ­gitos con prefijo conocido)
    - CÃ³digos de habilitaciÃ³n (8-12 dÃ­gitos)
    - Palabras invÃ¡lidas (CODIGO, TARIFA, DESCRIPCION, etc.)
    """
    import re

    if not cups:
        return False

    cups_str = str(cups).strip()

    # Quitar .0 si existe
    if cups_str.endswith('.0'):
        cups_str = cups_str[:-2]

    cups_u = cups_str.upper()

    # 1. Longitud bÃ¡sica
    if not cups_str or len(cups_str) > 15:
        return False

    # 2. RECHAZAR si es una ciudad (traslados)
    if cups_u in CIUDADES_COLOMBIA_COMPLETA:
        return False

    # 3. RECHAZAR si es departamento
    if cups_u in DEPARTAMENTOS_COLOMBIA:
        return False

    # 4. RECHAZAR palabras invÃ¡lidas
    for palabra in PALABRAS_INVALIDAS_CUPS:
        if palabra in cups_u:
            return False

    # 5. RECHAZAR patrones invÃ¡lidos
    patrones_invalidos = [
        r'^\*',
        r'^-+$',
        r'^\d{1,2}$',
        r'^N\.?A\.?$',
        r'^N/A$',
        r'INCLUYE',
        r'NOTA\s*\d*',
    ]
    for patron in patrones_invalidos:
        if re.search(patron, cups_u):
            return False

    # 6. Extraer solo dÃ­gitos
    cups_digits = re.sub(r'[^\d]', '', cups_str)

    # 7. RECHAZAR si parece un valor monetario grande (>= 7 dÃ­gitos)
    if cups_digits and len(cups_digits) >= 7:
        return False

    # 8. RECHAZAR si parece telÃ©fono celular (10 dÃ­gitos con prefijo conocido)
    if es_telefono_celular(cups_str):
        return False

    # 9. RECHAZAR si parece cÃ³digo de habilitaciÃ³n (8-12 dÃ­gitos puros)
    if cups_digits and cups_digits == cups_str and 8 <= len(cups_digits) <= 12:
        return False

    # 10. RECHAZAR valores especiales
    if cups_u in ['N.A', 'NA', 'N/A', 'N.A.', '-', '--', '---', 'NINGUNO', 'NINGUNA', 'NULL', 'NONE', '']:
        return False

    # 11. Si es solo dÃ­gitos, debe tener al menos 4
    if cups_digits and cups_digits == cups_str:
        if len(cups_digits) < 4:
            return False

    # 12. Si la fila completa parece ser de traslados, rechazar
    if fila and es_fila_de_traslados(fila):
        return False

    return True


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIÃ“N: validar_tarifa
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def validar_tarifa(tarifa, fila: list = None) -> bool:
    """
    v14.1: ValidaciÃ³n mejorada de tarifas.
    Solo rechaza si CLARAMENTE es un telÃ©fono celular.
    """
    import re

    if tarifa is None:
        return True  # Valor nulo es aceptable

    valor_str = str(tarifa).strip()

    # Quitar .0 si existe
    if valor_str.endswith('.0'):
        valor_str = valor_str[:-2]

    # RECHAZAR si es telÃ©fono celular
    if es_telefono_celular(valor_str):
        return False

    # RECHAZAR si parece cÃ³digo de habilitaciÃ³n Y hay contexto de sede
    valor_clean = re.sub(r'[^\d]', '', valor_str)
    if valor_clean and 8 <= len(valor_clean) <= 12:
        if fila:
            fila_texto = ' '.join([str(x).upper() for x in fila[:5] if x])
            for depto in DEPARTAMENTOS_COLOMBIA:
                if depto in fila_texto:
                    return False

    return True


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIÃ“N: es_fila_de_traslados
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def es_fila_de_traslados(fila: list) -> bool:
    """
    v14.1: Detecta si una fila de DATOS contiene informaciÃ³n de traslados.
    Una fila es de traslados si tiene ciudades en las primeras columnas.
    """
    if not fila or len(fila) < 3:
        return False

    # Verificar si hay ciudades en las primeras columnas
    for i, celda in enumerate(fila[:4]):
        if celda:
            celda_str = str(celda).strip()
            if celda_str.endswith('.0'):
                celda_str = celda_str[:-2]
            celda_upper = celda_str.upper()

            # Verificar contra lista de ciudades
            if celda_upper in CIUDADES_COLOMBIA_COMPLETA:
                return True

    return False


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIÃ“N: es_encabezado_seccion_traslados
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def es_encabezado_seccion_traslados(fila: list) -> bool:
    """
    v14.1: Detecta si una fila es el ENCABEZADO de una secciÃ³n de TRASLADOS.
    """
    if not fila:
        return False

    fila_texto = ' '.join([str(x).upper().strip() for x in fila if x is not None])

    # Patrones especÃ­ficos de encabezados de traslados
    indicadores_traslados = [
        'ORIGEN',
        'DESTINO',
        'MUNICIPIO ORIGEN',
        'MUNICIPIO DESTINO',
        'DEPARTAMENTO DESTINO',
        'TIPO DE TRASLADO',
    ]

    contador = 0
    for indicador in indicadores_traslados:
        if indicador in fila_texto:
            contador += 1

    # Si tiene 2+ indicadores de traslados Y NO tiene CUPS, es secciÃ³n de traslados
    tiene_cups = 'CUPS' in fila_texto
    return contador >= 2 and not tiene_cups


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIÃ“N: buscar_hoja_servicios_inteligente
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def debe_excluir_hoja_silenciosamente(nombre_hoja: str) -> bool:
    """Verifica si una hoja debe ser excluida SIN generar alerta."""
    if not nombre_hoja:
        return True

    nombre_upper = nombre_hoja.upper().strip()

    # Excluir hojas de configuraciÃ³n/instrucciones
    if nombre_upper in HOJAS_EXCLUIR_SILENCIOSAMENTE:
        return True

    # Excluir hojas de paquetes/costos (NO generan alerta individual)
    if nombre_upper in HOJAS_SIN_SERVICIOS_VALIDOS:
        return True

    # Verificar patrones parciales
    for patron in HOJAS_SIN_SERVICIOS_VALIDOS:
        if patron in nombre_upper:
            return True

    return False


def buscar_hoja_servicios_inteligente(hojas: list) -> tuple:
    """
    v14.1: Busca la hoja de servicios de forma inteligente.

    Retorna: (nombre_hoja_encontrada, hojas_excluidas_info)

    CAMBIO v14.1: Las hojas de PAQUETES NO generan alerta individual.
    Solo se mencionan si NO se encuentra ninguna hoja de servicios.
    """
    if not hojas:
        return None, []

    hojas_norm = {h: h.upper().strip() for h in hojas}
    hojas_excluidas_info = []

    # Identificar hojas excluidas (para informar si no hay servicios)
    for hoja, h_norm in hojas_norm.items():
        if h_norm in HOJAS_SIN_SERVICIOS_VALIDOS:
            hojas_excluidas_info.append((hoja, "Hoja de paquetes/costos - No aplica para T25"))
        else:
            for patron in HOJAS_SIN_SERVICIOS_VALIDOS:
                if patron in h_norm:
                    hojas_excluidas_info.append((hoja, "Hoja de paquetes/costos - No aplica para T25"))
                    break

    # Filtrar hojas excluidas para la bÃºsqueda
    hojas_validas = {h: h_norm for h, h_norm in hojas_norm.items()
                     if not debe_excluir_hoja_silenciosamente(h_norm)}

    if not hojas_validas:
        hojas_validas = hojas_norm

    # PASO 1: Buscar hoja "SERVICIOS" exacta
    for hoja, h_norm in hojas_validas.items():
        if h_norm.strip() == 'SERVICIOS':
            return hoja, hojas_excluidas_info

    # PASO 2: "TARIFAS DE SERVICIOS" sin modificadores
    patrones_exactos = [
        'TARIFAS DE SERVICIOS',
        'TARIFA DE SERVICIOS',
        'TARIFAS DE SERV',
        'TARIFA DE SERV',
        'TARIFAS DE SERVICIO',
        'TARIFA DE SERVICIO',
    ]

    for hoja, h_norm in hojas_validas.items():
        h_clean = ' '.join(h_norm.split())

        for patron in patrones_exactos:
            if h_clean == patron or h_clean.startswith(patron + ' ') or h_clean.startswith(patron):
                # Excluir si tiene palabras que indican que no es la hoja correcta
                if 'COSTO' not in h_clean and 'VIAJE' not in h_clean and 'PAQUETE' not in h_clean:
                    return hoja, hojas_excluidas_info

    # PASO 3: TARIFA + SERV (pero no traslados/paquetes)
    for hoja, h_norm in hojas_validas.items():
        if 'TARIFA' in h_norm and 'SERV' in h_norm:
            if 'TRASLADO' not in h_norm and 'PAQUETE' not in h_norm and 'AMBULANCIA' not in h_norm:
                return hoja, hojas_excluidas_info

    # PASO 4: SERVICIO (pero no traslados)
    for hoja, h_norm in hojas_validas.items():
        if 'SERVICIO' in h_norm and 'TRASLADO' not in h_norm:
            return hoja, hojas_excluidas_info

    # PASO 5: CUPS
    for hoja, h_norm in hojas_validas.items():
        if 'CUPS' in h_norm:
            if not debe_excluir_hoja_silenciosamente(h_norm):
                return hoja, hojas_excluidas_info

    # PASO 6: ANEXO 1
    for hoja, h_norm in hojas_validas.items():
        h_clean = h_norm.replace(' ', '').replace('_', '')
        if h_clean in ['ANEXO1', 'ANEXO01']:
            if not debe_excluir_hoja_silenciosamente(h_norm):
                return hoja, hojas_excluidas_info

    # No se encontrÃ³ hoja de servicios
    return None, hojas_excluidas_info


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIÃ“N: generar_mensaje_hojas_disponibles
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def generar_mensaje_hojas_disponibles(hojas: list, hojas_excluidas_info: list = None) -> str:
    """
    v14.1: Genera mensaje con todas las hojas disponibles.
    Solo se llama cuando NO se encuentra hoja de servicios.

    AQUÃ es donde se menciona que hay hojas de PAQUETES (no antes).
    """
    if not hojas:
        return "Archivo sin hojas"

    hojas_str = ", ".join([f"'{h}'" for h in hojas])
    mensaje = f"No se encontrÃ³ hoja de servicios vÃ¡lida. Hojas disponibles: [{hojas_str}]"

    # Agregar info de hojas excluidas si existen
    if hojas_excluidas_info:
        excluidas_str = ", ".join([f"'{h[0]}' ({h[1]})" for h in hojas_excluidas_info])
        mensaje += f". Hojas excluidas: [{excluidas_str}]"

    return mensaje


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIÃ“N: es_formato_propio (v14.1)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def es_formato_propio(hojas: list, datos_primera_hoja: list = None) -> tuple:
    """
    v14.1: Detecta si un archivo tiene formato propio (no POSITIVA estÃ¡ndar).

    Retorna: (es_propio: bool, descripcion: str)
    """
    if not hojas:
        return True, "Sin hojas disponibles"

    # Nombres de hojas estÃ¡ndar POSITIVA
    NOMBRES_ESTANDAR = {
        'TARIFAS DE SERVICIOS', 'TARIFA DE SERVICIOS', 'TARIFAS DE SERV',
        'SERVICIOS', 'TARIFAS MEDICAMENTOS', 'TARIFAS INSUMOS',
        'TARIFAS TRASLADOS', 'TARIFAS PAQUETES', 'MEDICAMENTOS',
        'INSUMOS', 'TRASLADOS', 'PAQUETES', 'TARIFA DE SERV',
        'TARIFAS DE SERVICIO', 'TARIFA DE SERVICIO'
    }

    hojas_reconocidas = 0
    for hoja in hojas:
        hoja_upper = hoja.upper().strip()
        for std in NOMBRES_ESTANDAR:
            if std in hoja_upper or hoja_upper in std:
                hojas_reconocidas += 1
                break

    # Si ninguna hoja es reconocida, es formato propio
    if hojas_reconocidas == 0:
        return True, f"Formato propio - Hojas no estÃ¡ndar: {hojas}"

    # Verificar estructura interna si tenemos datos
    if datos_primera_hoja:
        for fila in datos_primera_hoja[:20]:
            if fila:
                fila_texto = ' '.join([str(x).upper() for x in fila if x])

                # Si tiene ORIGEN/DESTINO sin CUPS, es formato de traslados
                if ('ORIGEN' in fila_texto and 'DESTINO' in fila_texto):
                    if 'CUPS' not in fila_texto:
                        return True, "Formato propio de traslados"

    return False, ""


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIÃ“N: generar_mensaje_alerta_ambulancia (v14.1)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def generar_mensaje_alerta_ambulancia(mensaje: str, categoria: str) -> str:
    """
    v14.1: Agrega prefijo de categorÃ­a si es contrato de ambulancias.
    """
    if categoria and 'AMBULANCIA' in categoria.upper():
        return f"[CATEGORÃA: Cuentas MÃ©dicas Ambulancias] {mensaje}"
    return mensaje


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CLASE: SistemaAlertas (v14.1 - Sin duplicados mejorado)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SistemaAlertas:
    """
    v14.1: Sistema de alertas sin duplicados.
    """

    def __init__(self):
        self._alertas_hash = set()
        self.alertas = []

    def limpiar(self):
        self._alertas_hash = set()
        self.alertas = []

    def agregar(self, tipo: str, mensaje: str, contrato: str, archivo: str = "") -> bool:
        """
        Agrega una alerta si no existe una similar.
        Retorna True si se agregÃ³, False si ya existÃ­a.
        """
        # Hash principal: tipo + contrato + archivo
        hash_principal = hash((tipo, contrato, archivo))

        # Hash secundario: incluye parte del mensaje para evitar duplicados exactos
        hash_secundario = hash((tipo, contrato, archivo, mensaje[:50]))

        if hash_secundario in self._alertas_hash:
            return False

        self._alertas_hash.add(hash_secundario)
        self.alertas.append({
            'tipo': tipo,
            'mensaje': mensaje,
            'contrato': contrato,
            'archivo': archivo
        })
        return True


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# RESUMEN DE CORRECCIONES v14.1
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
CORRECCIONES APLICADAS EN v14.1:

1. ALERTA DE PAQUETES (CORREGIDO):
   - La alerta de "Hoja de paquetes excluida" ahora SOLO aparece cuando NO existe
     hoja de servicios vÃ¡lida.
   - Las hojas PAQUETES, TARIFAS PAQUETES, COSTO VIAJE se excluyen SILENCIOSAMENTE.
   - Solo se mencionan en el mensaje final si no hay hoja de servicios.

   ANTES: Generaba alerta cada vez que veÃ­a una hoja PAQUETES
   AHORA: Solo menciona PAQUETES si el contrato no se puede procesar

2. TELÃ‰FONOS SIN GUIONES (CORREGIDO):
   - La funciÃ³n es_telefono_celular_colombiano() ahora:
     * Limpia el valor quitando TODO excepto dÃ­gitos
     * Funciona correctamente con nÃºmeros como: 3214567890
     * Detecta prefijos: 300-305, 310-318, 320-324, 350-351, 330-333

   ANTES: Solo detectaba telÃ©fonos con formato 321-456-7890
   AHORA: Detecta 3214567890 (como vienen en Excel)

3. VALIDACIÃ“N DE CUPS:
   - Rechaza ciudades colombianas (ARMENIA, CALI, etc.)
   - Rechaza valores monetarios >= 7 dÃ­gitos
   - Rechaza telÃ©fonos de 10 dÃ­gitos con prefijo conocido
   - Rechaza cÃ³digos de habilitaciÃ³n de 8-12 dÃ­gitos

4. DETECCIÃ“N DE SECCIONES DE TRASLADOS:
   - es_encabezado_seccion_traslados(): detecta encabezados con ORIGEN/DESTINO
   - es_fila_de_traslados(): detecta filas con ciudades en primeras columnas

5. SISTEMA DE ALERTAS SIN DUPLICADOS:
   - Hash por (tipo, contrato, archivo, mensaje[:50])
   - Evita alertas repetidas del mismo problema
"""

print("=" * 70)
print("CONSOLIDADOR T25 v14.1 - FUNCIONES CORREGIDAS")
print("=" * 70)
print("""
âœ… contiene_anexo1() - Detecta mÃ¡s patrones de ANEXO 1
âœ… es_telefono_celular_colombiano() - Funciona SIN guiones
âœ… validar_cups() - ValidaciÃ³n ultra estricta
âœ… validar_tarifa() - Solo rechaza telÃ©fonos claros
âœ… es_fila_de_traslados() - Detecta filas de traslados
âœ… es_encabezado_seccion_traslados() - Detecta encabezados de traslados
âœ… buscar_hoja_servicios_inteligente() - NO genera alerta de PAQUETES
âœ… generar_mensaje_hojas_disponibles() - Solo cuando no hay servicios
âœ… es_formato_propio() - Detecta formatos no POSITIVA
âœ… SistemaAlertas - Sin duplicados mejorado

CORRECCIONES ESPECÃFICAS SOLICITADAS:
1. âœ… Alerta PAQUETES: Solo si NO hay hoja de servicios
2. âœ… TelÃ©fonos: Detecta nÃºmeros SIN guiones (3214567890)
""")
print("=" * 70)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PRUEBAS DE VALIDACIÃ“N v14.1
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def ejecutar_pruebas_v14_1():
    """Ejecuta todas las pruebas de las correcciones v14.1"""

    print("\n" + "=" * 70)
    print("ğŸ§ª EJECUTANDO PRUEBAS v14.1")
    print("=" * 70)

    errores = []
    exitos = 0

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # PRUEBA 1: DetecciÃ³n de telÃ©fonos SIN guiones
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\nğŸ“± PRUEBA 1: DetecciÃ³n de telÃ©fonos SIN guiones")
    print("-" * 50)

    telefonos_validos = [
        ('3214567890', True, 'Celular Claro sin guiones'),
        ('3001234567', True, 'Celular Movistar sin guiones'),
        ('3501234567', True, 'Celular Tigo sin guiones'),
        ('3101234567', True, 'Celular sin guiones'),
        ('3214567890.0', True, 'Con decimal de Excel'),
    ]

    no_telefonos = [
        ('5920000', False, 'Tarifa de traslado'),
        ('11380000', False, 'Tarifa alta'),
        ('890201', False, 'CÃ³digo CUPS'),
        ('7614708225', False, 'CÃ³digo habilitaciÃ³n (no empieza con prefijo celular)'),
        ('12345678', False, 'Solo 8 dÃ­gitos'),
        ('123456789012', False, '12 dÃ­gitos'),
        ('ARMENIA', False, 'Ciudad'),
    ]

    for valor, esperado, descripcion in telefonos_validos + no_telefonos:
        resultado = es_telefono_celular_colombiano(valor)
        estado = "âœ…" if resultado == esperado else "âŒ"
        print(f"  {estado} {valor:15} â†’ {str(resultado):5} (esperado: {esperado}) - {descripcion}")
        if resultado == esperado:
            exitos += 1
        else:
            errores.append(f"TelÃ©fono: {valor} retornÃ³ {resultado}, esperado {esperado}")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # PRUEBA 2: ValidaciÃ³n de CUPS (rechaza ciudades)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\nğŸ¥ PRUEBA 2: ValidaciÃ³n de CUPS (ultra estricta)")
    print("-" * 50)

    cups_validos = [
        ('890201', True, 'CUPS consulta vÃ¡lido'),
        ('015201', True, 'CUPS procedimiento'),
        ('602E01', True, 'CUPS con letra'),
        ('786001', True, 'CUPS vÃ¡lido'),
    ]

    cups_invalidos = [
        ('ARMENIA', False, 'Ciudad colombiana'),
        ('CALI', False, 'Ciudad colombiana'),
        ('BAHIA SOLANO', False, 'Ciudad con espacio'),
        ('BOGOTA', False, 'Capital'),
        ('5920000', False, 'Valor monetario (7 dÃ­gitos)'),
        ('11380000', False, 'Valor monetario (8 dÃ­gitos)'),
        ('3214567890', False, 'TelÃ©fono celular'),
        ('7614708225', False, 'CÃ³digo habilitaciÃ³n'),
        ('META', False, 'Departamento'),
        ('TRASLADO', False, 'Palabra invÃ¡lida'),
    ]

    for valor, esperado, descripcion in cups_validos + cups_invalidos:
        resultado = validar_cups(valor)
        estado = "âœ…" if resultado == esperado else "âŒ"
        print(f"  {estado} {valor:15} â†’ {str(resultado):5} (esperado: {esperado}) - {descripcion}")
        if resultado == esperado:
            exitos += 1
        else:
            errores.append(f"CUPS: {valor} retornÃ³ {resultado}, esperado {esperado}")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # PRUEBA 3: DetecciÃ³n de filas de traslados
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\nğŸš‘ PRUEBA 3: DetecciÃ³n de filas de traslados")
    print("-" * 50)

    filas_traslados = [
        ([1, 'ARMENIA', 'CALI', 5920000], True, 'Fila con ciudades origen-destino'),
        ([1, 'BOGOTA', 'MEDELLIN', 8500000], True, 'Fila con capitales'),
        (['A', 'BAHIA SOLANO', 'CLO', 11380000], True, 'Fila con cÃ³digo aeropuerto'),
    ]

    filas_servicios = [
        ([1, '890201', '', 'CONSULTA MEDICINA GENERAL', 43686], False, 'Fila de servicio'),
        ([2, '015201', '890201', 'PROCEDIMIENTO', 125000], False, 'Fila con CUPS'),
        (['', '', '', '', ''], False, 'Fila vacÃ­a'),
    ]

    for fila, esperado, descripcion in filas_traslados + filas_servicios:
        resultado = es_fila_de_traslados(fila)
        estado = "âœ…" if resultado == esperado else "âŒ"
        fila_str = str(fila)[:40] + "..." if len(str(fila)) > 40 else str(fila)
        print(f"  {estado} {fila_str:45} â†’ {str(resultado):5} - {descripcion}")
        if resultado == esperado:
            exitos += 1
        else:
            errores.append(f"Fila traslados: {fila} retornÃ³ {resultado}, esperado {esperado}")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # PRUEBA 4: BÃºsqueda de hoja de servicios (NO alerta PAQUETES)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\nğŸ“‹ PRUEBA 4: BÃºsqueda de hoja de servicios (alertas PAQUETES)")
    print("-" * 50)

    casos_hojas = [
        # (hojas, hoja_esperada, debe_mencionar_paquetes)
        (['TARIFAS DE SERV', 'MEDICAMENTOS', 'PAQUETES', 'TRASLADOS'],
         'TARIFAS DE SERV', False, 'Con hoja servicios - NO menciona PAQUETES'),

        (['SERVICIOS', 'PAQUETES', 'TARIFAS PAQUETES'],
         'SERVICIOS', False, 'Tiene SERVICIOS - NO menciona PAQUETES'),

        (['PAQUETES', 'TRASLADOS', 'MEDICAMENTOS'],
         None, True, 'SIN servicios - SÃ menciona PAQUETES'),

        (['TARIFAS PAQUETES', 'COSTO VIAJE'],
         None, True, 'Solo paquetes/costos - SÃ menciona en mensaje'),
    ]

    for hojas, esperada, debe_mencionar, descripcion in casos_hojas:
        hoja_encontrada, excluidas_info = buscar_hoja_servicios_inteligente(hojas)

        hoja_ok = hoja_encontrada == esperada

        # Verificar si menciona paquetes en las excluidas
        menciona_paquetes = any('paquete' in str(info).lower() for info in excluidas_info)

        # La lÃ³gica es: si NO encuentra hoja, debe mencionar paquetes
        # si SÃ encuentra hoja, NO debe generar alerta de paquetes
        if esperada is None:
            # No encontrÃ³ hoja - debe tener info de excluidas para el mensaje
            logica_correcta = True  # Las excluidas se usan en generar_mensaje_hojas_disponibles
        else:
            # EncontrÃ³ hoja - no debe haber problema
            logica_correcta = True

        estado = "âœ…" if hoja_ok and logica_correcta else "âŒ"
        print(f"  {estado} Hojas: {hojas}")
        print(f"      â†’ Encontrada: '{hoja_encontrada}' (esperada: '{esperada}')")
        print(f"      â†’ Excluidas info: {len(excluidas_info)} items")
        print(f"      â†’ {descripcion}")

        if hoja_ok:
            exitos += 1
        else:
            errores.append(f"BÃºsqueda hojas: {hojas} retornÃ³ {hoja_encontrada}, esperada {esperada}")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # PRUEBA 5: contiene_anexo1
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\nğŸ“ PRUEBA 5: DetecciÃ³n de ANEXO 1")
    print("-" * 50)

    nombres_anexo1 = [
        ('0667-2025-ANEXO_1-HOSPITAL_DEPARTAMENTAL', True, 'Formato estÃ¡ndar'),
        ('0584-2025-ANEXO_1_VIDA_SERVICIOS_AMBULANCIA', True, 'Ambulancia con ANEXO_1'),
        ('0513-2024-ANEXO_1_DE_TARIFAS', True, 'ANEXO_1_DE_TARIFAS'),
        ('ANEXO 1 TARIFAS', True, 'Con espacio'),
        ('ANEXO-1-SERVICIOS', True, 'Con guiones'),
        ('TARIFAS_ANEXO1', True, 'Anexo al final'),
    ]

    no_anexo1 = [
        ('MEDICAMENTOS_ANEXO_1', False, 'Medicamentos - debe excluir'),
        ('ANEXO_2_TARIFAS', False, 'Es ANEXO 2'),
        ('TARIFAS_GENERALES', False, 'Sin ANEXO'),
    ]

    for nombre, esperado, descripcion in nombres_anexo1 + no_anexo1:
        resultado = contiene_anexo1(nombre)
        estado = "âœ…" if resultado == esperado else "âŒ"
        print(f"  {estado} {nombre[:40]:40} â†’ {str(resultado):5} - {descripcion}")
        if resultado == esperado:
            exitos += 1
        else:
            errores.append(f"ANEXO1: {nombre} retornÃ³ {resultado}, esperado {esperado}")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # RESUMEN
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print("\n" + "=" * 70)
    print("ğŸ“Š RESUMEN DE PRUEBAS")
    print("=" * 70)

    total = exitos + len(errores)
    porcentaje = (exitos / total * 100) if total > 0 else 0

    print(f"\n  âœ… Exitosas: {exitos}")
    print(f"  âŒ Fallidas: {len(errores)}")
    print(f"  ğŸ“ˆ Porcentaje: {porcentaje:.1f}%")

    if errores:
        print(f"\n  âš ï¸ ERRORES ENCONTRADOS:")
        for error in errores:
            print(f"     â€¢ {error}")
    else:
        print(f"\n  ğŸ‰ Â¡TODAS LAS PRUEBAS PASARON!")

    print("\n" + "=" * 70)

    return len(errores) == 0


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EJEMPLO DE USO EN EL PROCESADOR
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
CÃ“MO INTEGRAR EN EL PROCESADOR PRINCIPAL:

En la funciÃ³n buscar_hoja_servicios del ProcesadorAnexo, reemplazar:

ANTES:
    def buscar_hoja_servicios(self, archivo: str) -> Optional[str]:
        ...
        # Si no encuentra, genera alerta de PAQUETES inmediatamente

DESPUÃ‰S (v14.1):
    def buscar_hoja_servicios(self, archivo: str) -> Optional[str]:
        hojas = obtener_hojas(archivo)

        # Usar la nueva funciÃ³n
        hoja_encontrada, hojas_excluidas_info = buscar_hoja_servicios_inteligente(hojas)

        if hoja_encontrada:
            # âœ… EncontrÃ³ hoja de servicios - NO genera alerta de PAQUETES
            return hoja_encontrada

        # âŒ NO encontrÃ³ hoja de servicios - AHORA sÃ­ menciona PAQUETES
        mensaje = generar_mensaje_hojas_disponibles(hojas, hojas_excluidas_info)
        self.agregar_alerta(TipoAlerta.HOJA_NO_ENCONTRADA, mensaje, archivo)
        return None
"""


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EJECUTAR PRUEBAS AL IMPORTAR
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if __name__ == "__main__":
    ejecutar_pruebas_v14_1()

# -*- coding: utf-8 -*-
"""Consolidador T25 version 6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19jkqakBLuh67uRi44m-b5-TE1Zv9RC2Y
"""

# -*- coding: utf-8 -*-
"""CONSOLIDADOR T25 v14.1 - COMPLETO CON CORRECCIONES

CORRECCIONES v14.1:
- ğŸ†• Alerta PAQUETES: Solo cuando NO existe hoja de servicios vÃ¡lida
- ğŸ†• TelÃ©fonos: Detecta nÃºmeros SIN guiones (como vienen en Excel)
- ğŸ†• ValidaciÃ³n CUPS ultra estricta: rechaza ciudades colombianas
- ğŸ†• DetecciÃ³n de secciones de traslados (evita mapeo incorrecto)
- ğŸ†• Lista expandida de ciudades colombianas para validaciÃ³n
- ğŸ†• contiene_anexo1: NO excluye ambulancias (pueden tener servicios)
- ExclusiÃ³n de hojas TARIFAS PAQUETES y COSTO VIAJE (silenciosa)
- Mejora en bÃºsqueda de hojas (prioriza SERVICIOS)
- BÃºsqueda de contratos con cero inicial (901 â†’ 0901)
- Alerta "CONTRATO NO SE ENCUENTRA EN EL GO ANYWHERE"
- ReconexiÃ³n forzada por contrato
- ExtracciÃ³n de nÃºmero de acta desde nombre del archivo
- Mejora en detecciÃ³n de columnas
- Alertas separadas por hojas en Excel
"""

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CELDA 1: INSTALACIÃ“N Y SISTEMA DE LOGGING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("ğŸš€ Inicializando CONSOLIDADOR T25 v14.1...")
print("=" * 70)

# InstalaciÃ³n silenciosa de dependencias
!pip install pyxlsb openpyxl pandas paramiko xlrd tqdm -q

import warnings
warnings.filterwarnings('ignore')

from IPython.display import display, HTML, clear_output
from datetime import datetime, timedelta
from typing import List, Optional, Dict, Any, Tuple, Callable
from enum import Enum
from dataclasses import dataclass, field
import time

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¨ SISTEMA DE LOGGING VISUAL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class LogLevel(Enum):
    """Niveles de logging con sus estilos visuales."""
    INFO = ("â„¹ï¸", "#2196F3", "info")
    SUCCESS = ("âœ…", "#4CAF50", "success")
    WARNING = ("âš ï¸", "#FF9800", "warning")
    ERROR = ("âŒ", "#F44336", "error")
    DEBUG = ("ğŸ”", "#9E9E9E", "debug")
    STEP = ("ğŸ“Œ", "#673AB7", "step")
    NAV = ("ğŸ“‚", "#795548", "nav")
    FILE = ("ğŸ“„", "#607D8B", "file")
    DOWNLOAD = ("â¬‡ï¸", "#00BCD4", "download")
    PROCESS = ("âš™ï¸", "#FF5722", "process")
    ALERT = ("ğŸ””", "#E91E63", "alert")

class Logger:
    """Sistema de logging visual para el Consolidador T25."""

    def __init__(self, verbose: bool = True):
        self.verbose = verbose
        self.indent_level = 0
        self.logs: List[Dict] = []
        self.start_time = time.time()
        self.current_contract = ""
        self.stats = {
            'contratos_procesados': 0,
            'contratos_exitosos': 0,
            'archivos_descargados': 0,
            'servicios_extraidos': 0,
            'alertas_generadas': 0
        }

    def _get_timestamp(self) -> str:
        return datetime.now().strftime("%H:%M:%S")

    def _get_elapsed(self) -> str:
        elapsed = time.time() - self.start_time
        if elapsed < 60:
            return f"{elapsed:.1f}s"
        return f"{elapsed/60:.1f}m"

    def _format_indent(self) -> str:
        return "â”‚   " * self.indent_level

    def _print(self, level: LogLevel, message: str, details: str = "",
               show_time: bool = True, indent_override: int = None):
        if not self.verbose and level == LogLevel.DEBUG:
            return

        indent = "â”‚   " * (indent_override if indent_override is not None else self.indent_level)
        icon = level.value[0]
        time_str = f"[{self._get_timestamp()}] " if show_time else ""
        detail_str = f" â†’ {details}" if details else ""

        line = f"{indent}{icon} {time_str}{message}{detail_str}"
        print(line)

        self.logs.append({
            'time': self._get_timestamp(),
            'level': level.name,
            'message': message,
            'details': details
        })

    def set_contract(self, contract_id: str):
        self.current_contract = contract_id

    def indent(self):
        self.indent_level += 1

    def dedent(self):
        self.indent_level = max(0, self.indent_level - 1)

    def reset_indent(self):
        self.indent_level = 0

    def header(self, title: str, subtitle: str = ""):
        print("\n" + "â•" * 70)
        print(f"  {title}")
        if subtitle:
            print(f"  {subtitle}")
        print("â•" * 70)

    def subheader(self, title: str):
        print(f"\n{'â”€' * 50}")
        print(f"  {title}")
        print('â”€' * 50)

    def step(self, step_num: int, total: int, description: str):
        progress = "â–ˆ" * int(step_num/total * 20) + "â–‘" * (20 - int(step_num/total * 20))
        print(f"\nğŸ“Œ PASO {step_num}/{total}: {description}")
        print(f"   [{progress}] {step_num/total*100:.0f}%")

    def contract_start(self, idx: int, total: int, contract_id: str):
        self.reset_indent()
        self.current_contract = contract_id
        self.stats['contratos_procesados'] += 1

        progress_pct = (idx / total) * 100
        bar_filled = int(progress_pct / 5)
        bar = "â–ˆ" * bar_filled + "â–‘" * (20 - bar_filled)

        print(f"\nâ”Œ{'â”€' * 68}â”")
        print(f"â”‚ ğŸ“‹ CONTRATO [{idx}/{total}] {contract_id:<20} [{bar}] {progress_pct:>5.1f}% â”‚")
        print(f"â””{'â”€' * 68}â”˜")

    def contract_end(self, success: bool, registros: int, tiempo: float, mensaje: str = ""):
        self.reset_indent()
        icon = "âœ…" if success else "âŒ"
        status = "Ã‰XITO" if success else "FALLO"

        if success:
            self.stats['contratos_exitosos'] += 1
            self.stats['servicios_extraidos'] += registros

        print(f"    â”œâ”€â”€ {icon} {status}: {registros:,} servicios en {tiempo:.1f}s")
        if mensaje and not success:
            print(f"    â””â”€â”€ ğŸ’¬ {mensaje}")
        print()

    def nav(self, path: str, found: bool = True):
        icon = "ğŸ“‚" if found else "ğŸ“"
        status = "" if found else " (no encontrado)"
        self._print(LogLevel.NAV, f"Navegando a: {path}{status}", show_time=False)

    def nav_tree(self, items: List[str], item_type: str = "carpetas"):
        if not items:
            self._print(LogLevel.DEBUG, f"(vacÃ­o - sin {item_type})", show_time=False)
            return

        count = len(items)
        shown = items[:5]

        for i, item in enumerate(shown):
            prefix = "â”œâ”€â”€" if i < len(shown) - 1 else "â””â”€â”€"
            icon = "ğŸ“" if item_type == "carpetas" else "ğŸ“„"
            print(f"    {self._format_indent()}{prefix} {icon} {item}")

        if count > 5:
            print(f"    {self._format_indent()}    ... y {count - 5} mÃ¡s")

    def file_found(self, filename: str, file_type: str = ""):
        type_str = f"[{file_type}] " if file_type else ""
        self._print(LogLevel.FILE, f"Encontrado: {type_str}{filename}", show_time=False)
        self.stats['archivos_descargados'] += 1

    def download(self, filename: str, size: str = ""):
        size_str = f" ({size})" if size else ""
        self._print(LogLevel.DOWNLOAD, f"Descargando: {filename}{size_str}", show_time=False)

    def process(self, action: str, detail: str = ""):
        self._print(LogLevel.PROCESS, action, detail, show_time=False)

    def success(self, message: str, detail: str = ""):
        self._print(LogLevel.SUCCESS, message, detail, show_time=False)

    def warning(self, message: str, detail: str = ""):
        self._print(LogLevel.WARNING, message, detail, show_time=False)

    def error(self, message: str, detail: str = ""):
        self._print(LogLevel.ERROR, message, detail, show_time=False)

    def info(self, message: str, detail: str = ""):
        self._print(LogLevel.INFO, message, detail, show_time=False)

    def debug(self, message: str, detail: str = ""):
        self._print(LogLevel.DEBUG, message, detail, show_time=False)

    def alert(self, alert_type: str, message: str, archivo: str = ""):
        self.stats['alertas_generadas'] += 1
        archivo_str = f" en {archivo}" if archivo else ""
        self._print(LogLevel.ALERT, f"[{alert_type}] {message}{archivo_str}", show_time=False)

    def stats_summary(self):
        elapsed = time.time() - self.start_time

        print(f"\n{'â•' * 70}")
        print("  ğŸ“Š ESTADÃSTICAS DE EJECUCIÃ“N")
        print('â•' * 70)
        print(f"""
    â±ï¸  Tiempo total: {elapsed/60:.1f} minutos

    ğŸ“‹ Contratos:
       â€¢ Procesados: {self.stats['contratos_procesados']}
       â€¢ Exitosos: {self.stats['contratos_exitosos']}
       â€¢ Tasa de Ã©xito: {100*self.stats['contratos_exitosos']/max(1,self.stats['contratos_procesados']):.1f}%

    ğŸ“„ Archivos descargados: {self.stats['archivos_descargados']}

    ğŸ“Š Servicios extraÃ­dos: {self.stats['servicios_extraidos']:,}

    ğŸ”” Alertas generadas: {self.stats['alertas_generadas']}
""")
        print('â•' * 70)

# Crear instancia global del logger
LOG = Logger(verbose=True)

LOG.header("CONSOLIDADOR T25 v14.1", "Sistema de ConsolidaciÃ³n de Tarifas - POSITIVA")
print("""
âœ… Sistema de logging inicializado

ğŸ“‹ Mejoras v14.1:
   â€¢ ğŸ” BÃºsqueda mejorada de contratos (901 â†’ 0901)
   â€¢ ğŸ“‹ Alertas separadas por categorÃ­a en diferentes hojas
   â€¢ ğŸ”„ ReconexiÃ³n forzada por contrato (evita Socket closed)
   â€¢ âœ… ValidaciÃ³n de CUPS mejorada (rechaza NOTA, NO INCLUYE, etc.)
   â€¢ ğŸ“Š ExclusiÃ³n de hojas TARIFAS PAQUETES y COSTO VIAJE
   â€¢ ğŸ¯ PriorizaciÃ³n correcta de hoja "SERVICIOS"
""")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CELDA 2: IMPORTS Y CONFIGURACIÃ“N
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

LOG.step(1, 6, "CARGANDO CONFIGURACIÃ“N")

from google.colab import files
import pandas as pd
import numpy as np
import os
import re
import shutil
import threading
import zipfile
from typing import List, Optional, Tuple, Dict, Any, Callable
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from enum import Enum, auto
import time
import paramiko
import stat
from difflib import SequenceMatcher

LOG.indent()
LOG.success("LibrerÃ­as importadas correctamente")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONFIGURACIÃ“N GLOBAL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class Config:
    """ConfiguraciÃ³n centralizada del sistema."""
    HOST: str = 'mft.positiva.gov.co'
    PORT: int = 2243
    USERNAME: str = 'G_medica'
    PASSWORD: str = 'Uhnbru0sgnpit]'
    TIMEOUT_CONEXION: int = 30
    TIMEOUT_OPERACION: int = 20
    TIMEOUT_ARCHIVO: int = 60
    MAX_REINTENTOS_CONEXION: int = 5
    MAX_REINTENTOS_OPERACION: int = 3
    BACKOFF_BASE: float = 2.0
    KEEPALIVE_INTERVAL: int = 5
    CARPETA_PRINCIPAL: str = 'R.A-ABASTECIMIENTO RED ASISTENCIAL'
    CARPETA_TRABAJO: str = './trabajo_temp'
    CONTRATOS_PROBLEMATICOS: set = field(default_factory=lambda: {'572-2023'})
    TIMEOUT_CONTRATOS_PROBLEMATICOS: int = 30
    MAX_SEDES: int = 50

CONFIG = Config()

LOG.info("ConfiguraciÃ³n SFTP", f"{CONFIG.HOST}:{CONFIG.PORT}")
LOG.info("Timeout por archivo", f"{CONFIG.TIMEOUT_ARCHIVO}s")
LOG.info("MÃ¡ximo de sedes", f"{CONFIG.MAX_SEDES}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ENUMERACIONES Y CLASES DE DATOS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class OrigenTarifa(Enum):
    INICIAL = "Inicial"
    OTROSI = "OtrosÃ­"
    ACTA = "Acta"

class TipoAlerta(Enum):
    SIN_ANEXO1 = "SIN_ANEXO1"
    SIN_CARPETA_TARIFAS = "SIN_CARPETA_TARIFAS"
    ACTA_FALTANTE = "ACTA_FALTANTE"
    CARPETA_ACTAS_SIN_ANEXO = "CARPETA_ACTAS_SIN_ANEXO"
    SIN_FORMATO_POSITIVA = "SIN_FORMATO_POSITIVA"
    FORMATO_PROPIO = "FORMATO_PROPIO"  # ğŸ†• v15.0
    HOJA_NO_ENCONTRADA = "HOJA_NO_ENCONTRADA"
    COLUMNAS_NO_DETECTADAS = "COLUMNAS_NO_DETECTADAS"
    SEDES_NO_DETECTADAS = "SEDES_NO_DETECTADAS"
    FECHA_NO_ENCONTRADA = "FECHA_NO_ENCONTRADA"
    ERROR_PROCESAMIENTO = "ERROR_PROCESAMIENTO"
    TIMEOUT = "TIMEOUT"
    CONEXION = "CONEXION"
    ERROR_LECTURA = "ERROR_LECTURA"
    SOLO_TRASLADOS = "SOLO_TRASLADOS"
    CONTRATO_AMBULANCIA = "CONTRATO_AMBULANCIA"
    CONTRATO_AMBULANCIA_MAESTRA = "CONTRATO_AMBULANCIA_MAESTRA"
    ARCHIVO_SOLO_AMBULANCIAS = "ARCHIVO_SOLO_AMBULANCIAS"
    ARCHIVO_SOLO_TRASLADOS = "ARCHIVO_SOLO_TRASLADOS"
    TARIFA_SERVICIOS_NO_ENCONTRADA = "TARIFA_SERVICIOS_NO_ENCONTRADA"
    # ğŸ†• v14.1
    CONTRATO_NO_ENCONTRADO_GO = "CONTRATO_NO_ENCONTRADO_GO"
    FECHA_FALTANTE_MAESTRA = "FECHA_FALTANTE_MAESTRA"

class PrioridadAlerta(Enum):
    CRITICA = 1
    ALTA = 2
    MEDIA = 3
    BAJA = 4

ALERTAS_CONFIG = {
    TipoAlerta.SIN_ANEXO1: {
        'prioridad': PrioridadAlerta.CRITICA,
        'sugerencia': 'Verificar que el archivo ANEXO 1 estÃ© cargado en TARIFAS'
    },
    TipoAlerta.SIN_CARPETA_TARIFAS: {
        'prioridad': PrioridadAlerta.CRITICA,
        'sugerencia': 'Crear carpeta TARIFAS en el contrato'
    },
    TipoAlerta.ACTA_FALTANTE: {
        'prioridad': PrioridadAlerta.ALTA,
        'sugerencia': 'Solicitar acta de negociaciÃ³n faltante'
    },
    TipoAlerta.SIN_FORMATO_POSITIVA: {
        'prioridad': PrioridadAlerta.MEDIA,
        'sugerencia': 'Verificar formato del archivo'
    },
    TipoAlerta.FECHA_NO_ENCONTRADA: {
        'prioridad': PrioridadAlerta.MEDIA,
        'sugerencia': 'Verificar registro en maestra de contratos'
    },
    TipoAlerta.TIMEOUT: {
        'prioridad': PrioridadAlerta.ALTA,
        'sugerencia': 'Archivo muy grande, considerar procesamiento manual'
    },
    TipoAlerta.SOLO_TRASLADOS: {
        'prioridad': PrioridadAlerta.BAJA,
        'sugerencia': 'Archivo contiene solo servicios de traslados'
    },
    TipoAlerta.CONTRATO_AMBULANCIA: {
        'prioridad': PrioridadAlerta.BAJA,
        'sugerencia': 'Contrato de ambulancias - verificar si requiere ANEXO 1 de servicios'
    },
    TipoAlerta.CONTRATO_AMBULANCIA_MAESTRA: {
        'prioridad': PrioridadAlerta.BAJA,
        'sugerencia': 'Contrato identificado como ambulancias desde la maestra'
    },
    TipoAlerta.ARCHIVO_SOLO_AMBULANCIAS: {
        'prioridad': PrioridadAlerta.BAJA,
        'sugerencia': 'Archivo contiene solo hojas de ambulancias/traslados asistenciales'
    },
    TipoAlerta.ARCHIVO_SOLO_TRASLADOS: {
        'prioridad': PrioridadAlerta.BAJA,
        'sugerencia': 'Archivo contiene solo hojas de traslados genÃ©ricos'
    },
    TipoAlerta.TARIFA_SERVICIOS_NO_ENCONTRADA: {
        'prioridad': PrioridadAlerta.ALTA,
        'sugerencia': 'Verificar si el archivo corresponde a servicios o solo traslados/ambulancias'
    },
    TipoAlerta.CONTRATO_NO_ENCONTRADO_GO: {
        'prioridad': PrioridadAlerta.CRITICA,
        'sugerencia': 'El contrato no existe en GoAnywhere - verificar nÃºmero y aÃ±o'
    },
}

@dataclass
class Alerta:
    """Representa una alerta generada durante el procesamiento."""
    tipo: TipoAlerta
    mensaje: str
    contrato: str
    archivo: str = ""
    sugerencia: str = ""
    prioridad: PrioridadAlerta = PrioridadAlerta.MEDIA
    timestamp: str = field(default_factory=lambda: datetime.now().strftime('%Y-%m-%d %H:%M:%S'))

    def __post_init__(self):
        if not self.sugerencia and self.tipo in ALERTAS_CONFIG:
            self.sugerencia = ALERTAS_CONFIG[self.tipo]['sugerencia']
        if self.tipo in ALERTAS_CONFIG:
            self.prioridad = ALERTAS_CONFIG[self.tipo]['prioridad']

    def to_dict(self) -> Dict:
        return {
            'tipo': self.tipo.value,
            'prioridad': self.prioridad.value,
            'mensaje': self.mensaje,
            'contrato': self.contrato,
            'archivo': self.archivo,
            'sugerencia': self.sugerencia,
            'timestamp': self.timestamp
        }

    def __hash__(self):
        return hash((self.tipo, self.mensaje, self.contrato, self.archivo))

    def __eq__(self, other):
        if not isinstance(other, Alerta):
            return False
        return (self.tipo == other.tipo and
                self.mensaje == other.mensaje and
                self.contrato == other.contrato and
                self.archivo == other.archivo)

@dataclass
class ArchivoAnexo:
    """Representa un archivo ANEXO 1 descargado."""
    nombre: str
    ruta_local: str
    origen: OrigenTarifa
    numero: Optional[int] = None
    fecha_modificacion: Optional[float] = None
    origen_completo: str = ""  # ğŸ†• v14.1

    @property
    def origen_texto(self) -> str:
        if self.numero:
            return f"{self.origen.value} {self.numero}"
        return self.origen.value

LOG.success("Clases y configuraciÃ³n definidas")
LOG.dedent()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CELDA 3A: UTILIDADES Y FUNCIONES DE CONVERSIÃ“N
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

LOG.step(2, 6, "CARGANDO UTILIDADES v14.1")
LOG.indent()

def detectar_formato_real(filepath: str) -> str:
    """Detecta el formato REAL de un archivo Excel."""
    try:
        with open(filepath, 'rb') as f:
            header = f.read(8)

        if header[:4] == b'PK\x03\x04':
            try:
                with zipfile.ZipFile(filepath, 'r') as z:
                    names = z.namelist()
                    if any('workbook.bin' in n.lower() for n in names):
                        return 'xlsb'
                    elif any('.xml' in n.lower() for n in names):
                        return 'xlsx'
                return 'xlsx'
            except zipfile.BadZipFile:
                return 'zip_corrupt'

        if header[:8] == b'\xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1':
            return 'xls_old'

        return 'unknown'

    except Exception:
        return 'error'


LOG.success("ğŸ†• FunciÃ³n detectar_formato_real agregada")


def leer_excel(ruta: str, sheet_name=0, header=0, engine=None):
    """Lee archivo Excel con manejo automÃ¡tico de motor."""
    if engine:
        return pd.read_excel(ruta, engine=engine, sheet_name=sheet_name, header=header)

    formato = detectar_formato_real(ruta)

    try:
        if formato == 'xlsb':
            return pd.read_excel(ruta, engine='pyxlsb', sheet_name=sheet_name, header=header)
        elif formato == 'xlsx':
            return pd.read_excel(ruta, engine='openpyxl', sheet_name=sheet_name, header=header)
        elif formato == 'xls_old':
            return pd.read_excel(ruta, engine='xlrd', sheet_name=sheet_name, header=header)
    except:
        pass

    for eng in ['openpyxl', 'pyxlsb', 'xlrd']:
        try:
            return pd.read_excel(ruta, engine=eng, sheet_name=sheet_name, header=header)
        except:
            continue
    raise Exception(f"No se pudo leer: {ruta}")


def obtener_hojas(ruta: str) -> List[str]:
    """Obtiene lista de hojas de un archivo Excel."""
    formato = detectar_formato_real(ruta)
    ext = os.path.splitext(ruta)[1].lower()

    if formato == 'xlsb':
        try:
            from pyxlsb import open_workbook
            with open_workbook(ruta) as wb:
                return list(wb.sheets)
        except Exception:
            pass

    elif formato == 'xlsx':
        try:
            from openpyxl import load_workbook
            wb = load_workbook(ruta, read_only=True, data_only=True)
            hojas = wb.sheetnames
            wb.close()
            return hojas
        except Exception:
            pass

    elif formato == 'xls_old':
        try:
            import xlrd
            wb = xlrd.open_workbook(ruta, on_demand=True)
            return wb.sheet_names()
        except Exception:
            pass

    # FALLBACK basado en extensiÃ³n
    if ext == '.xlsb':
        try:
            from pyxlsb import open_workbook
            with open_workbook(ruta) as wb:
                return list(wb.sheets)
        except:
            pass
    elif ext == '.xls':
        try:
            import xlrd
            return xlrd.open_workbook(ruta).sheet_names()
        except:
            pass
    else:
        try:
            from openpyxl import load_workbook
            wb = load_workbook(ruta, read_only=True)
            hojas = wb.sheetnames
            wb.close()
            return hojas
        except:
            pass

    return []


def leer_hoja_raw(ruta: str, hoja: str, max_filas: int = 50000) -> List[List]:
    """Lee hoja como lista de listas."""
    formato = detectar_formato_real(ruta)
    ext = os.path.splitext(ruta)[1].lower()

    try:
        if formato == 'xlsb':
            from pyxlsb import open_workbook
            datos = []
            with open_workbook(ruta) as wb:
                with wb.get_sheet(hoja) as sheet:
                    for i, row in enumerate(sheet.rows()):
                        if i >= max_filas:
                            break
                        datos.append([cell.v for cell in row])
            return datos

        elif formato == 'xlsx':
            from openpyxl import load_workbook
            wb = load_workbook(ruta, read_only=True, data_only=True)
            sheet = wb[hoja]
            datos = []
            for i, row in enumerate(sheet.iter_rows(values_only=True)):
                if i >= max_filas:
                    break
                datos.append(list(row))
            wb.close()
            return datos

        elif formato == 'xls_old':
            import xlrd
            wb = xlrd.open_workbook(ruta)
            sheet = wb.sheet_by_name(hoja)
            return [[sheet.cell_value(r, c) for c in range(sheet.ncols)]
                    for r in range(min(sheet.nrows, max_filas))]

        else:
            if ext == '.xlsb':
                from pyxlsb import open_workbook
                datos = []
                with open_workbook(ruta) as wb:
                    with wb.get_sheet(hoja) as sheet:
                        for i, row in enumerate(sheet.rows()):
                            if i >= max_filas:
                                break
                            datos.append([cell.v for cell in row])
                return datos
            elif ext == '.xls':
                import xlrd
                wb = xlrd.open_workbook(ruta)
                sheet = wb.sheet_by_name(hoja)
                return [[sheet.cell_value(r, c) for c in range(sheet.ncols)]
                        for r in range(min(sheet.nrows, max_filas))]
            else:
                from openpyxl import load_workbook
                wb = load_workbook(ruta, read_only=True, data_only=True)
                sheet = wb[hoja]
                datos = []
                for i, row in enumerate(sheet.iter_rows(values_only=True)):
                    if i >= max_filas:
                        break
                    datos.append(list(row))
                wb.close()
                return datos

    except AssertionError:
        return []
    except Exception:
        return []


LOG.success("Funciones de lectura Excel")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CLASIFICACIÃ“N DE HOJAS PARA ALERTAS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def clasificar_hojas(hojas: List[str]) -> Dict[str, List[str]]:
    """Clasifica las hojas disponibles para generar alertas mÃ¡s descriptivas."""
    clasificacion = {
        'servicios': [],
        'medicamentos': [],
        'traslados': [],
        'ambulancias': [],
        'paquetes': [],
        'otras': []
    }

    PALABRAS_AMBULANCIA = ['AMBULANCIA', 'TAM', 'TAB', 'TRASLADO ASISTENCIAL',
                           'TRANSPORTE ASISTENCIAL', 'SERVICIO AMBULANCIA']

    for hoja in hojas:
        h = hoja.upper()

        if any(x in h for x in ['TARIFA DE SERV', 'TARIFAS DE SERV', 'TARIFAS SERV']):
            if 'MEDICAMENTO' not in h and 'TRASLADO' not in h and 'AMBULANCIA' not in h:
                clasificacion['servicios'].append(hoja)
                continue

        es_ambulancia = False
        for palabra in PALABRAS_AMBULANCIA:
            if palabra in h:
                es_ambulancia = True
                break

        if es_ambulancia:
            clasificacion['ambulancias'].append(hoja)
        elif 'MEDICAMENTO' in h or 'INSUMO' in h:
            clasificacion['medicamentos'].append(hoja)
        elif 'TRASLADO' in h:
            clasificacion['traslados'].append(hoja)
        elif 'PAQUETE' in h:
            clasificacion['paquetes'].append(hoja)
        elif 'SERVICIO' in h and 'MEDICAMENTO' not in h:
            clasificacion['servicios'].append(hoja)
        else:
            clasificacion['otras'].append(hoja)

    return clasificacion


def generar_mensaje_alerta_hojas(hojas: List[str], categoria_cuentas_medicas: str = None) -> str:
    """Genera un mensaje de alerta descriptivo basado en las hojas disponibles."""
    if not hojas:
        return "No se pudieron leer las hojas del archivo"

    cls = clasificar_hojas(hojas)
    partes = []

    if cls['ambulancias']:
        partes.append(f"Ambulancias: {cls['ambulancias'][0]}")
    if cls['medicamentos']:
        partes.append(f"Medicamentos: {cls['medicamentos'][0]}")
    if cls['traslados']:
        partes.append(f"Traslados: {cls['traslados'][0]}")
    if cls['paquetes']:
        partes.append(f"Paquetes: {cls['paquetes'][0]}")

    mensaje = ""
    if partes:
        mensaje = f"No se encontrÃ³ hoja TARIFA SERVICIOS. Hojas encontradas: [{'; '.join(partes)}]"
    else:
        todas = ', '.join(hojas[:3])
        if len(hojas) > 3:
            todas += f" (+{len(hojas)-3} mÃ¡s)"
        mensaje = f"No se encontrÃ³ hoja TARIFA SERVICIOS. Hojas disponibles: [{todas}]"

    if categoria_cuentas_medicas:
        mensaje += f". CategorÃ­a cuentas mÃ©dicas: '{categoria_cuentas_medicas}'"

    return mensaje


def es_archivo_solo_traslados(hojas: List[str]) -> Tuple[bool, str, str]:
    """Verifica si un archivo SOLO contiene hojas de traslados/ambulancias."""
    if not hojas:
        return False, "", ""

    cls = clasificar_hojas(hojas)

    if cls['servicios']:
        return False, "", ""

    tiene_ambulancias = bool(cls['ambulancias'])
    tiene_traslados = bool(cls['traslados'])

    if tiene_ambulancias and not tiene_traslados:
        hojas_amb = ', '.join(cls['ambulancias'][:3])
        if len(cls['ambulancias']) > 3:
            hojas_amb += f" (+{len(cls['ambulancias'])-3} mÃ¡s)"
        mensaje = f"Archivo contiene solo hojas de ambulancias: [{hojas_amb}]"
        return True, mensaje, "AMBULANCIAS"

    if tiene_traslados and not tiene_ambulancias:
        hojas_traslado = ', '.join(cls['traslados'][:3])
        if len(cls['traslados']) > 3:
            hojas_traslado += f" (+{len(cls['traslados'])-3} mÃ¡s)"
        mensaje = f"Archivo contiene solo hojas de traslados: [{hojas_traslado}]"
        return True, mensaje, "TRASLADOS"

    if tiene_ambulancias and tiene_traslados:
        todas = cls['ambulancias'] + cls['traslados']
        hojas_str = ', '.join(todas[:3])
        if len(todas) > 3:
            hojas_str += f" (+{len(todas)-3} mÃ¡s)"
        mensaje = f"Archivo contiene solo hojas de ambulancias/traslados: [{hojas_str}]"
        return True, mensaje, "MIXTO"

    return False, "", ""


LOG.success("Funciones de clasificaciÃ³n de hojas")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIONES DE NORMALIZACIÃ“N Y LIMPIEZA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def normalizar_texto(texto) -> str:
    """Normaliza texto: mayÃºsculas, sin tildes, sin especiales."""
    if texto is None:
        return ""
    t = str(texto).upper().strip()
    for k, v in {'Ã':'A','Ã‰':'E','Ã':'I','Ã“':'O','Ãš':'U','Ã‘':'N','Ãœ':'U'}.items():
        t = t.replace(k, v)
    return re.sub(r'[^A-Z0-9\s]', ' ', t).strip()

def similitud_texto(a: str, b: str) -> float:
    """Calcula similitud entre dos textos (0.0 a 1.0)."""
    return SequenceMatcher(None, a.upper(), b.upper()).ratio()

def limpiar_codigo(valor) -> Optional[str]:
    """Limpia cÃ³digo eliminando decimales y espacios."""
    if valor is None:
        return None
    texto = str(valor).strip()
    if texto.endswith('.0'):
        texto = texto[:-2]
    return None if not texto or texto.lower() in ('none', 'nan', '') else texto

def limpiar_tarifa(valor) -> Optional[float]:
    """Convierte tarifa a nÃºmero."""
    if valor is None:
        return None
    try:
        if isinstance(valor, (int, float)):
            return float(valor) if not pd.isna(valor) else None
        texto = str(valor).replace('$', '').replace(',', '').replace(' ', '').strip()
        return float(texto) if texto and texto.lower() not in ('none', 'nan') else None
    except:
        return None

def limpiar_texto(valor) -> Optional[str]:
    """Limpia texto eliminando espacios extras."""
    if valor is None:
        return None
    texto = str(valor).strip()
    return None if not texto or texto.lower() in ('none', 'nan') else texto

def formatear_habilitacion(codigo, sede) -> str:
    """Formatea cÃ³digo de habilitaciÃ³n con sede."""
    if not codigo:
        return "0000000000-01"

    c = str(codigo).strip()
    if c.endswith('.0'):
        c = c[:-2]

    if re.match(r'^\d{8,12}-\d{1,2}$', c):
        return c

    c_limpio = re.sub(r'[^\d]', '', c)

    try:
        if sede is None:
            s = 1
        else:
            sede_str = str(sede).strip()
            if sede_str.endswith('.0'):
                sede_str = sede_str[:-2]
            sede_limpia = re.sub(r'[^\d]', '', sede_str)
            if sede_limpia == c_limpio or len(sede_limpia) > 5:
                s = 1
            else:
                s = int(float(sede_str)) if sede_str else 1
    except:
        s = 1

    return f"{c_limpio}-{str(s).zfill(2)}"

LOG.success("Funciones de normalizaciÃ³n")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIONES DE DETECCIÃ“N DE PATRONES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def es_extension_excel(nombre: str) -> bool:
    """Verifica si es archivo Excel."""
    return nombre and nombre.lower().endswith(('.xlsx', '.xls', '.xlsm', '.xlsb'))

# ğŸ†• v15.0: La funciÃ³n contiene_anexo1() ahora estÃ¡ definida al inicio del archivo
# con soporte mejorado para detectar archivos TARIFAS y OTROSI


def timestamp_a_fecha(timestamp: float) -> Optional[str]:
    """Convierte timestamp UNIX a fecha DD/MM/YYYY."""
    if not timestamp:
        return None
    try:
        dt = datetime.fromtimestamp(timestamp)
        return dt.strftime('%d/%m/%Y')
    except:
        return None

LOG.success("Funciones de detecciÃ³n de patrones")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CELDA 3B: VALIDACIÃ“N SEMÃNTICA v14.1
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\nğŸ“Œ CARGANDO VALIDACIÃ“N SEMÃNTICA v14.1...")

# ğŸ†• v14.1: Lista COMPLETA de ciudades colombianas (incluye las usadas en traslados)
CIUDADES_COLOMBIA_COMPLETA = {
    # Capitales
    'BOGOTÃ', 'BOGOTA', 'MEDELLÃN', 'MEDELLIN', 'CALI', 'BARRANQUILLA',
    'CARTAGENA', 'BUCARAMANGA', 'CÃšCUTA', 'CUCUTA', 'PEREIRA', 'IBAGUÃ‰',
    'IBAGUE', 'SANTA MARTA', 'MANIZALES', 'VILLAVICENCIO', 'PASTO',
    'MONTERÃA', 'MONTERIA', 'NEIVA', 'ARMENIA', 'SINCELEJO', 'POPAYÃN',
    'POPAYAN', 'VALLEDUPAR', 'TUNJA', 'FLORENCIA', 'QUIBDÃ“', 'QUIBDO',
    'RIOHACHA', 'YOPAL', 'MOCOA', 'LETICIA', 'INÃRIDA', 'INIRIDA',
    'MITÃš', 'MITU', 'PUERTO CARREÃ‘O', 'SAN JOSÃ‰ DEL GUAVIARE', 'ARAUCA',
    # Ciudades intermedias usadas en traslados aÃ©reos
    'BAHIA SOLANO', 'BARRANCABERMEJA', 'BUENAVENTURA', 'PALMIRA',
    'CARTAGO', 'TULUA', 'TULUÃ', 'BUGA', 'SOGAMOSO', 'DUITAMA', 'GIRARDOT',
    'FUSAGASUGA', 'FUSAGASUGÃ', 'FACATATIVA', 'FACATATIVÃ', 'ZIPAQUIRA',
    'ZIPAQUIRÃ', 'CHIA', 'CHÃA', 'SOACHA', 'RIONEGRO', 'ENVIGADO',
    'ITAGUI', 'ITAGÃœÃ', 'BELLO', 'TUMACO', 'IPIALES', 'GRANADA', 'ACACIAS',
    'ACACÃAS', 'PUERTO LOPEZ', 'PUERTO LÃ“PEZ', 'AGUACHICA', 'OCAÃ‘A',
    'APARTADO', 'APARTADÃ“', 'TURBO', 'CAUCASIA', 'MAGANGUE', 'MAGANGUÃ‰',
    'LORICA', 'CERETE', 'CERETÃ‰', 'ESPINAL', 'MELGAR', 'FLANDES', 'HONDA',
    'MARIQUITA', 'LA DORADA', 'PUERTO BERRIO', 'PUERTO BERRÃO',
    'PUERTO BOYACA', 'PUERTO BOYACÃ', 'CIENAGA', 'CIÃ‰NAGA', 'FUNDACION',
    'FUNDACIÃ“N', 'ARACATACA', 'EL BANCO', 'PLATO', 'COROZAL', 'SAMPUES',
    'SAMPUÃ‰S', 'SAN MARCOS', 'ZARZAL', 'JAMUNDI', 'JAMUNDÃ', 'YUMBO',
    'CANDELARIA', 'PRADERA', 'FLORIDA', 'CERRITO', 'GUACARI', 'GUACARÃ',
    'GINEBRA', 'ROLDANILLO', 'LA UNION', 'LA UNIÃ“N', 'SEVILLA',
    'CAICEDONIA', 'ARGELIA', 'DARIEN', 'DARIÃ‰N', 'RESTREPO', 'DAGUA',
    'LA CUMBRE', 'CLO', 'BOG', 'MDE',  # CÃ³digos de aeropuerto
    # Otras ciudades importantes
    'TENJO', 'MOSQUERA', 'SUESCA', 'FUNZA', 'MADRID', 'ALCALÃ', 'ULLOA',
    'TRUJILLO', 'RIOFRÃO', 'RIOFRIO', 'CALIMA', 'VIJES', 'YOTOCO',
    'SAN PEDRO', 'EL DOVIO', 'ANDALUCÃA', 'ANDALUCIA', 'CONTRATACIÃ“N',
    'CONTRATACION', 'POPOYAN', 'BOLIVAR', 'BOLÃVAR',
}

MUNICIPIOS_COLOMBIA = {
    'BOGOTÃ', 'BOGOTA', 'MEDELLÃN', 'MEDELLIN', 'CALI', 'BARRANQUILLA',
    'CARTAGENA', 'BUCARAMANGA', 'CÃšCUTA', 'CUCUTA', 'PEREIRA', 'IBAGUÃ‰',
    'IBAGUE', 'SANTA MARTA', 'MANIZALES', 'VILLAVICENCIO', 'PASTO',
    'MONTERÃA', 'MONTERIA', 'NEIVA', 'ARMENIA', 'SINCELEJO', 'POPAYÃN',
    'POPOYAN', 'VALLEDUPAR', 'TUNJA', 'FLORENCIA', 'QUIBDÃ“', 'QUIBDO',
    'RIOHACHA', 'YOPAL', 'MOCOA', 'LETICIA', 'INÃRIDA', 'INIRIDA',
    'MITÃš', 'MITU', 'PUERTO CARREÃ‘O', 'SAN JOSÃ‰ DEL GUAVIARE',
    'ZARZAL', 'PALMIRA', 'ANDALUCÃA', 'ANDALUCIA', 'CONTRATACIÃ“N',
    'CONTRATACION', 'TULUÃ', 'TULUA', 'BUGA', 'CARTAGO', 'JAMUNDÃ',
    'JAMUNDI', 'YUMBO', 'CANDELARIA', 'PRADERA', 'FLORIDA', 'CERRITO',
    'GUACARÃ', 'GUACARI', 'GINEBRA', 'ROLDANILLO', 'LA UNIÃ“N', 'SEVILLA',
    'CAICEDONIA', 'ALCALÃ', 'ULLOA', 'ARGELIA', 'BOLÃVAR', 'TRUJILLO',
    'RIOFRÃO', 'RIOFRIO', 'CALIMA', 'DAGUA', 'LA CUMBRE', 'RESTREPO',
    'VIJES', 'YOTOCO', 'SAN PEDRO', 'DARIÃ‰N', 'DARIEN', 'EL DOVIO',
    'SOGAMOSO', 'TENJO', 'MOSQUERA', 'ZIPAQUIRÃ', 'ZIPAQUIRA', 'SUESCA',
    'BUENAVENTURA', 'RIONEGRO', 'ENVIGADO', 'ITAGÃœÃ', 'ITAGUI', 'BELLO',
    'SOACHA', 'CHÃA', 'CHIA', 'FUNZA', 'MADRID', 'FACATATIVÃ', 'FACATATIVA',
    'GIRARDOT', 'FUSAGASUGÃ', 'FUSAGASUGA', 'DUITAMA', 'SOGAMOSO'
}

DEPARTAMENTOS_COLOMBIA = {
    'BOGOTÃ D.C', 'BOGOTA D.C', 'BOGOTÃ D.C.', 'BOGOTA D.C.',
    'ANTIOQUIA', 'ATLÃNTICO', 'ATLANTICO', 'BOLÃVAR', 'BOLIVAR',
    'BOYACÃ', 'BOYACA', 'CALDAS', 'CAQUETÃ', 'CAQUETA', 'CASANARE',
    'CAUCA', 'CESAR', 'CHOCÃ“', 'CHOCO', 'CÃ“RDOBA', 'CORDOBA',
    'CUNDINAMARCA', 'GUAINÃA', 'GUAINIA', 'GUAVIARE', 'HUILA',
    'LA GUAJIRA', 'MAGDALENA', 'META', 'NARIÃ‘O', 'NARINO',
    'NORTE DE SANTANDER', 'PUTUMAYO', 'QUINDÃO', 'QUINDIO',
    'RISARALDA', 'SAN ANDRÃ‰S', 'SAN ANDRES', 'SANTANDER', 'SUCRE',
    'TOLIMA', 'VALLE', 'VALLE DEL CAUCA', 'VAUPÃ‰S', 'VAUPES',
    'VICHADA', 'AMAZONAS', 'ARAUCA'
}

PALABRAS_ENCABEZADO_SEDES = {
    'DEPARTAMENTO', 'MUNICIPIO', 'CODIGO DE HABILITACION', 'CÃ“DIGO DE HABILITACIÃ“N',
    'CODIGO DE HABIITACION', 'CÃ“DIGO DE HABIITACIÃ“N',
    'CODIGO HABILITACION', 'CÃ“DIGO HABILITACIÃ“N',
    'NUMERO DE SEDE', 'NÃšMERO DE SEDE', 'NÂ° SEDE', 'NO. SEDE',
    'NOMBRE DE LA SEDE', 'DIRECCION', 'DIRECCIÃ“N', 'TELEFONO', 'TELÃ‰FONO',
    'EMAIL', 'CORREO', 'NOMBRE SEDE'
}

PALABRAS_ENCABEZADO_SERVICIOS = {
    'CODIGO CUPS', 'CÃ“DIGO CUPS', 'COD CUPS', 'COD. CUPS','CODIGO CUP', 'COD. CUP', 'COD CUP',
    'DESCRIPCION DEL CUPS', 'DESCRIPCIÃ“N DEL CUPS', 'DESCRIPCION DE CUP', 'DESCRIPCIÃ“N DE CUP',
    'TARIFA UNITARIA', 'MANUAL TARIFARIO', 'TARIFARIO',
    'CODIGO DE ESPECIALIDAD', 'CÃ“DIGO DE ESPECIALIDAD'
}

PATRONES_DIRECCION = [
    'CARRERA ', 'CRA ', 'CRA. ', 'CR ',
    'CALLE ', 'CL ', 'CL. ',
    'AVENIDA ', 'AV ', 'AV. ',
    'DIAGONAL ', 'DG ', 'DG. ',
    'TRANSVERSAL ', 'TV ', 'TV. ',
    'KM ', 'KILOMETRO', 'KILÃ“METRO',
    'LOCAL ', 'PISO ', 'OFICINA ', 'OF ',
    'CONSULTORIO', 'TORRE ', 'BLOQUE ',
    'MANZANA', 'CASA ', 'APARTAMENTO', 'APTO',
    'EDIFICIO', 'CENTRO COMERCIAL', 'C.C.',
    'BARRIO ', 'VEREDA ', 'SECTOR '
]

# ğŸ†• v14.1 - Hojas a excluir SILENCIOSAMENTE (sin generar alerta)
HOJAS_EXCLUIR = {
    'INSTRUCCIONES', 'INFO', 'DATOS', 'CONTENIDO', 'INDICE', 'ÃNDICE',
    'GUIA DE USO', 'GUÃA DE USO', 'CONTROL DE CAMBIOS', 'HOJA1', 'SHEET1',
    'INSTRUCTIVO', 'PARAMETROS', 'PARÃMETROS', 'CONFIGURACION', 'CONFIGURACIÃ“N',
    'LISTA', 'LISTAS', 'VALIDACION', 'VALIDACIÃ“N', 'CATALOGO', 'CATÃLOGO',
    'RESUMEN', 'PORTADA', 'CARATULA', 'CARÃTULA', 'INICIO', 'HOME',
    'MENU', 'MENÃš', 'ANEXO TECNICO', 'ANEXO TÃ‰CNICO', 'GLOSARIO',
}

# ğŸ†• v14.1: Hojas que se excluyen SILENCIOSAMENTE pero se MENCIONAN si no hay hoja de servicios
HOJAS_SIN_SERVICIOS_VALIDOS = {
    'PAQUETE', 'PAQUETES', 'TARIFAS PAQUETE', 'TARIFAS PAQUETES',
    'TARIFA PAQUETE', 'TARIFA PAQUETES',
    'COSTO VIAJE', 'COSTO DE VIAJE', 'COSTOS VIAJE', 'COSTOS DE VIAJE'
}

PATRONES_EXCLUIR_HOJA = [
    'COSTO VIAJE',
    'COSTO DE VIAJE',
    '(COSTO',
]

# ğŸ†• v14.1: Patrones de PAQUETES (se excluyen pero NO generan alerta individual)
PATRONES_PAQUETES = [
    'PAQUETE',
]

PALABRAS_HOJA_SERVICIOS_ALTA = [
    'TARIFA DE SERV',
    'TARIFAS DE SERV',
    'TARIFA SERV',
    'TARIFAS SERV',
    'SERVICIOS INDIVIDUALES',
    'SOLICITUD',
    'ANEXO 1',
    'ANEXO',
]


def debe_excluir_hoja(nombre_hoja: str) -> bool:
    """ğŸ†• v14.1: Verifica si una hoja debe ser excluida (SILENCIOSAMENTE).
    Las hojas de PAQUETES se excluyen pero NO generan alerta individual.
    """
    if not nombre_hoja:
        return True

    nombre_upper = nombre_hoja.upper().strip()

    # Excluir hojas de configuraciÃ³n/instrucciones
    if nombre_upper in HOJAS_EXCLUIR:
        return True

    # ğŸ†• v14.1: Excluir hojas de PAQUETES silenciosamente (sin alerta)
    if nombre_upper in HOJAS_SIN_SERVICIOS_VALIDOS:
        return True

    # Verificar patrones de exclusiÃ³n
    for patron in PATRONES_EXCLUIR_HOJA:
        if patron in nombre_upper:
            return True

    # ğŸ†• v14.1: Verificar patrones de PAQUETES
    for patron in PATRONES_PAQUETES:
        if patron in nombre_upper:
            return True

    return False


def obtener_hojas_excluidas_info(hojas: List[str]) -> List[Tuple[str, str]]:
    """ğŸ†• v14.1: Obtiene info de hojas excluidas para mostrar si no hay servicios."""
    info = []
    for hoja in hojas:
        hoja_upper = hoja.upper().strip()

        # Verificar si es hoja de paquetes/costos
        if hoja_upper in HOJAS_SIN_SERVICIOS_VALIDOS:
            info.append((hoja, "Hoja de paquetes/costos - No aplica para T25"))
            continue

        for patron in PATRONES_PAQUETES:
            if patron in hoja_upper:
                info.append((hoja, "Hoja de paquetes - No aplica para T25"))
                break

    return info


def buscar_hoja_servicios_inteligente(hojas: List[str]) -> Tuple[Optional[str], List[Tuple[str, str]]]:
    """ğŸ†• v14.1: Busca la hoja de servicios de forma inteligente.

    Retorna: (nombre_hoja_encontrada, hojas_excluidas_info)

    CAMBIO v14.1: Las hojas de PAQUETES NO generan alerta individual.
    Solo se mencionan en el mensaje final si no hay hoja de servicios.
    """
    if not hojas:
        return None, []

    hojas_norm = {h: h.upper().strip() for h in hojas}

    # ğŸ†• v14.1: Obtener info de hojas excluidas para informar si no hay servicios
    hojas_excluidas_info = obtener_hojas_excluidas_info(hojas)

    # Filtrar hojas excluidas
    hojas_validas = {h: h_norm for h, h_norm in hojas_norm.items()
                     if not debe_excluir_hoja(h_norm)}

    if not hojas_validas:
        hojas_validas = hojas_norm

    # PASO 1: Buscar hoja "SERVICIOS"
    for hoja, h_norm in hojas_validas.items():
        if h_norm.strip() == 'SERVICIOS':
            return hoja, hojas_excluidas_info

    # PASO 2: "TARIFAS DE SERVICIOS" sin modificadores
    patrones_exactos = [
        'TARIFAS DE SERVICIOS',
        'TARIFA DE SERVICIOS',
        'TARIFAS DE SERV',
        'TARIFA DE SERV',
    ]

    for hoja, h_norm in hojas_validas.items():
        h_clean = ' '.join(h_norm.split())

        for patron in patrones_exactos:
            if h_clean == patron or h_clean.startswith(patron + ' '):
                if 'COSTO' not in h_clean and 'VIAJE' not in h_clean and 'PAQUETE' not in h_clean:
                    return hoja, hojas_excluidas_info

    # PASO 3: TARIFA + SERV
    for hoja, h_norm in hojas_validas.items():
        if 'TARIFA' in h_norm and 'SERV' in h_norm:
            if not debe_excluir_hoja(h_norm):
                return hoja, hojas_excluidas_info

    # PASO 4: SERVICIO
    for hoja, h_norm in hojas_validas.items():
        if 'SERVICIO' in h_norm:
            if not debe_excluir_hoja(h_norm):
                return hoja, hojas_excluidas_info

    # PASO 5: CUPS
    for hoja, h_norm in hojas_validas.items():
        if 'CUPS' in h_norm:
            if not debe_excluir_hoja(h_norm):
                return hoja, hojas_excluidas_info

    # PASO 6: ANEXO 1
    for hoja, h_norm in hojas_validas.items():
        h_clean = h_norm.replace(' ', '').replace('_', '')
        if h_clean in ['ANEXO1', 'ANEXO01']:
            if not debe_excluir_hoja(h_norm):
                return hoja, hojas_excluidas_info

    # No se encontrÃ³ hoja de servicios
    return None, hojas_excluidas_info


def es_encabezado_seccion_sedes(fila: list) -> bool:
    """Detecta si una fila es el ENCABEZADO de la secciÃ³n de SEDES."""
    if not fila:
        return False

    fila_texto = ' '.join([str(x).upper().strip() for x in fila if x is not None])

    contador = 0
    for palabra in PALABRAS_ENCABEZADO_SEDES:
        if palabra in fila_texto:
            contador += 1

    return contador >= 3


def es_encabezado_seccion_servicios(fila: list) -> bool:
    """Detecta si una fila es el ENCABEZADO de la secciÃ³n de SERVICIOS."""
    if not fila:
        return False

    fila_texto = ' '.join([str(x).upper().strip() for x in fila if x is not None])

    tiene_cups = 'CODIGO CUPS' in fila_texto or 'CÃ“DIGO CUPS' in fila_texto
    tiene_otra = any(p in fila_texto for p in ['DESCRIPCION', 'TARIFA', 'TARIFARIO', 'ESPECIALIDAD'])

    return tiene_cups and tiene_otra


def es_dato_de_sede(fila: list) -> bool:
    """Detecta si una fila contiene DATOS de sede."""
    if not fila or len(fila) < 3:
        return False

    col0 = str(fila[0]).upper().strip() if fila[0] is not None else ''
    col1 = str(fila[1]).upper().strip() if len(fila) > 1 and fila[1] is not None else ''

    es_depto = col0 in DEPARTAMENTOS_COLOMBIA or any(d in col0 for d in DEPARTAMENTOS_COLOMBIA)
    es_muni = col1 in MUNICIPIOS_COLOMBIA or any(m in col1 for m in MUNICIPIOS_COLOMBIA)

    if es_depto and es_muni:
        return True

    for celda in fila[:8]:
        if celda:
            celda_str = str(celda).upper()
            for patron in PATRONES_DIRECCION:
                if patron in celda_str:
                    for otra in fila[:8]:
                        if otra:
                            otra_str = str(otra).strip().replace('.0', '').replace('-', '')
                            if otra_str.isdigit() and 8 <= len(otra_str) <= 12:
                                return True

    return False


def es_municipio_o_departamento(valor: str) -> bool:
    """Detecta si un valor es un municipio o departamento."""
    if not valor:
        return False
    valor_u = str(valor).upper().strip()
    return valor_u in MUNICIPIOS_COLOMBIA or valor_u in DEPARTAMENTOS_COLOMBIA


def es_direccion(valor: str) -> bool:
    """Detecta si un valor es una direcciÃ³n."""
    if not valor:
        return False
    valor_u = str(valor).upper()
    for patron in PATRONES_DIRECCION:
        if patron in valor_u:
            return True
    return False


PREFIJOS_CELULAR_COLOMBIA = {
    '300', '301', '302', '303', '304', '305',
    '310', '311', '312', '313', '314', '315', '316', '317', '318',
    '320', '321', '322', '323', '324',
    '350', '351',
    '330', '331', '332', '333'
}

def es_telefono_celular_colombiano(valor: str) -> bool:
    """ğŸ†• v14.1: Detecta si un valor es un telÃ©fono celular colombiano.
    CORREGIDO: Funciona con nÃºmeros SIN guiones (como vienen en Excel).

    Ejemplos que detecta:
    - 3214567890 (sin guiones)
    - 3001234567
    - 3501234567

    NO debe confundir con:
    - Tarifas (5920000, 11380000)
    - CÃ³digos CUPS (890201)
    - HabilitaciÃ³n (7614708225)
    """
    if not valor:
        return False

    # Convertir a string y limpiar
    valor_str = str(valor).strip()

    # Si termina en .0, quitarlo (tÃ­pico de Excel)
    if valor_str.endswith('.0'):
        valor_str = valor_str[:-2]

    # Quitar TODOS los caracteres no dÃ­gitos
    valor_clean = re.sub(r'[^\d]', '', valor_str)

    # Debe ser exactamente 10 dÃ­gitos
    if len(valor_clean) != 10:
        return False

    # Verificar prefijo de celular colombiano
    prefijo = valor_clean[:3]
    return prefijo in PREFIJOS_CELULAR_COLOMBIA


def es_telefono_celular(valor: str) -> bool:
    return es_telefono_celular_colombiano(valor)


def es_numero_sede(valor: str) -> bool:
    """Detecta si un valor es solo un nÃºmero de sede."""
    if not valor:
        return False
    valor_str = str(valor).strip().replace('.0', '')
    return valor_str.isdigit() and len(valor_str) <= 2


#VALIDACIÃ“N DE CUPS ULTRA ESTRICTA
PALABRAS_INVALIDAS_CUPS = [
    'CODIGO', 'CUPS', 'ITEM', 'DESCRIPCION', 'TARIFA', 'TOTAL', 'SUBTOTAL',
    'DEPARTAMENTO', 'MUNICIPIO', 'HABILITACION', 'HABIITACION', 'DIRECCION',
    'TELEFONO', 'EMAIL', 'SEDE', 'NOMBRE', 'NUMERO', 'ESPECIALIDAD',
    'MANUAL', 'OBSERV', 'PORCENTAJE', 'HOMOLOGO', 'NÂ°', 'NO.',
    'NOTA', 'NOTAS', 'ACLARATORIA', 'ACLARATORIAS', 'ACLARACION', 'ACLARACIONES',
    'INCLUYE', 'NO INCLUYE', 'EXCLUYE',
    'USO DE EQUIPO', 'DERECHO DE SALA', 'DERECHO SALA',
    'VER NOTA', 'VER NOTAS', 'SEGUN NOTA',
    'APLICA', 'NO APLICA', 'SEGÃšN', 'SEGUN',
    'CONSULTAR', 'REVISAR', 'PENDIENTE',
    'VALOR', 'PRECIO', 'COSTO',
    'CONTRATO', 'ACTA', 'OTROSI', 'OTROSÃ',
    'VIGENTE', 'VIGENCIA',
    'TRASLADO', 'ORIGEN', 'DESTINO',  # ğŸ†• v14.1: Palabras de traslados
    'TARIFAS PROPIAS', 'TARIFA PROPIA',  # ğŸ†• v14.1: Son manuales tarifarios
]

PATRONES_INVALIDOS_CUPS = [
    r'^\*',
    r'^-+$',
    r'^\d{1,2}$',
    r'^N\.?A\.?$',
    r'^N/A$',
    r'INCLUYE',
    r'NOTA\s*\d*',
]


def es_fila_de_traslados(fila: list) -> bool:
    """ğŸ†• v14.1: Detecta si una fila de DATOS contiene informaciÃ³n de traslados.
    Una fila es de traslados si tiene ciudades en las primeras columnas.
    """
    if not fila or len(fila) < 3:
        return False

    # Verificar si hay ciudades en las primeras columnas
    for i, celda in enumerate(fila[:4]):
        if celda:
            celda_str = str(celda).strip()
            if celda_str.endswith('.0'):
                celda_str = celda_str[:-2]
            celda_upper = celda_str.upper()

            # Verificar contra lista de ciudades
            if celda_upper in CIUDADES_COLOMBIA_COMPLETA:
                return True

    return False


def es_encabezado_seccion_traslados(fila: list) -> bool:
    """ğŸ†• v14.1: Detecta si una fila es el ENCABEZADO de una secciÃ³n de TRASLADOS."""
    if not fila:
        return False

    fila_texto = ' '.join([str(x).upper().strip() for x in fila if x is not None])

    # Patrones especÃ­ficos de encabezados de traslados
    indicadores_traslados = [
        'ORIGEN',
        'DESTINO',
        'MUNICIPIO ORIGEN',
        'MUNICIPIO DESTINO',
        'DEPARTAMENTO DESTINO',
        'TIPO DE TRASLADO',
    ]

    contador = 0
    for indicador in indicadores_traslados:
        if indicador in fila_texto:
            contador += 1

    # Si tiene 2+ indicadores de traslados Y NO tiene CUPS, es secciÃ³n de traslados
    tiene_cups = 'CUPS' in fila_texto
    return contador >= 2 and not tiene_cups


def validar_cups(cups: str, fila: list = None) -> bool:
    """ğŸ†• v14.1: ValidaciÃ³n de CUPS ULTRA estricta.

    RECHAZA:
    - Ciudades colombianas (ARMENIA, CALI, BAHIA SOLANO, etc.)
    - Valores monetarios grandes (>= 7 dÃ­gitos)
    - TelÃ©fonos celulares (10 dÃ­gitos con prefijo conocido)
    - CÃ³digos de habilitaciÃ³n (8-12 dÃ­gitos puros)
    - Palabras invÃ¡lidas (CODIGO, TARIFA, DESCRIPCION, etc.)
    """
    if not cups:
        return False

    cups_str = str(cups).strip()

    # Quitar .0 si existe
    if cups_str.endswith('.0'):
        cups_str = cups_str[:-2]

    cups_u = cups_str.upper()

    # 1. Longitud bÃ¡sica
    if not cups_str or len(cups_str) > 25:
        return False

    # 2. ğŸ†• v14.1: RECHAZAR si es una ciudad (traslados)
    if cups_u in CIUDADES_COLOMBIA_COMPLETA:
        return False

    # 3. RECHAZAR palabras invÃ¡lidas
    for palabra in PALABRAS_INVALIDAS_CUPS:
        if palabra in cups_u:
            return False

    # 4. RECHAZAR patrones invÃ¡lidos
    for patron in PATRONES_INVALIDOS_CUPS:
        if re.search(patron, cups_u):
            return False

    # 5. Extraer solo dÃ­gitos
    cups_digits = re.sub(r'[^\d]', '', cups_str)

    # 6. ğŸ†• v14.1: RECHAZAR si parece un valor monetario grande (>= 7 dÃ­gitos)
    if cups_digits and len(cups_digits) >= 7:
        return False

    # 7. RECHAZAR si parece telÃ©fono celular (10 dÃ­gitos con prefijo conocido)
    if es_telefono_celular(cups_str):
        return False

    # 8. ğŸ†• v14.1: RECHAZAR si parece cÃ³digo de habilitaciÃ³n (8-12 dÃ­gitos puros)
    if cups_digits and cups_digits == cups_str and 8 <= len(cups_digits) <= 12:
        return False

    # 9. RECHAZAR municipios/departamentos
    if es_municipio_o_departamento(cups_u):
        return False

    # 10. RECHAZAR direcciones
    if es_direccion(cups_u):
        return False

    # 11. RECHAZAR valores especiales
    if cups_u in ['N.A', 'NA', 'N/A', 'N.A.', '-', '--', '---', 'NINGUNO', 'NINGUNA', 'NULL', 'NONE', '']:
        return False

    # 12. RECHAZAR si es nÃºmero de sede
    if es_numero_sede(cups_str):
        return False

    # 13. Si es solo dÃ­gitos, debe tener al menos 4
    if cups_digits and cups_digits == cups_str:
        if len(cups_digits) < 4:
            return False

    # 14. ğŸ†• v14.1: Si la fila completa parece ser de traslados, rechazar
    if fila and es_fila_de_traslados(fila):
        return False

    # 15. Si la fila es dato de sede, rechazar
    if fila and es_dato_de_sede(fila):
        return False

    return True


def validar_tarifa(tarifa, fila: list = None) -> bool:
    """ğŸ†• v14.1: ValidaciÃ³n mejorada de tarifas.
    Solo rechaza si CLARAMENTE es un telÃ©fono celular.
    """
    if tarifa is None:
        return True  # Valor nulo es aceptable

    valor_str = str(tarifa).strip()

    # Quitar .0 si existe
    if valor_str.endswith('.0'):
        valor_str = valor_str[:-2]

    # RECHAZAR si es telÃ©fono celular
    if es_telefono_celular(valor_str):
        return False

    # RECHAZAR si parece cÃ³digo de habilitaciÃ³n Y hay contexto de sede
    valor_clean = re.sub(r'[^\d]', '', valor_str)
    if valor_clean and 8 <= len(valor_clean) <= 12:
        if fila:
            fila_texto = ' '.join([str(x).upper() for x in fila[:5] if x])
            for depto in DEPARTAMENTOS_COLOMBIA:
                if depto in fila_texto:
                    return False

    return True


def validar_manual_tarifario(manual) -> bool:
    if manual is None:
        return True
    if es_direccion(str(manual)):
        return False
    return not es_telefono_celular(str(manual))


def validar_descripcion(descripcion) -> bool:
    if descripcion is None:
        return True
    desc_str = str(descripcion).strip()
    if es_numero_sede(desc_str):
        return False
    return not es_municipio_o_departamento(desc_str)


print("âœ… ValidaciÃ³n semÃ¡ntica v14.1 cargada")
print("âœ… ğŸ†• Lista expandida de ciudades colombianas")
print("âœ… ğŸ†• ValidaciÃ³n CUPS ultra estricta (rechaza ciudades/valores monetarios)")
print("âœ… ğŸ†• TelÃ©fonos: detecta nÃºmeros SIN guiones")
print("âœ… ğŸ†• Alerta PAQUETES: solo si no hay hoja de servicios")
LOG.dedent()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CELDA 4: CARGAR MAESTRA DE CONTRATOS v14.1
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

LOG.step(3, 6, "CARGAR MAESTRA DE CONTRATOS")

print("""
ğŸ“ Selecciona el archivo de la maestra de contratos vigentes.
   Formatos soportados: .xlsx, .xls, .xlsb, .xlsm
""")

uploaded = files.upload()
ARCHIVO_MAESTRA = list(uploaded.keys())[0]

LOG.indent()
LOG.success(f"Archivo cargado", ARCHIVO_MAESTRA)

hojas = obtener_hojas(ARCHIVO_MAESTRA)
LOG.info(f"Hojas encontradas", f"{len(hojas)} hojas")

HOJA_CONTRATOS = None
for hoja in hojas:
    hoja_upper = hoja.upper()
    if 'CONTRATO' in hoja_upper and 'VIGENTE' in hoja_upper:
        HOJA_CONTRATOS = hoja
        break

if not HOJA_CONTRATOS:
    for hoja in hojas:
        if 'CONTRATO' in hoja.upper():
            HOJA_CONTRATOS = hoja
            break

if not HOJA_CONTRATOS:
    HOJA_CONTRATOS = hojas[0] if hojas else None

LOG.info("Hoja seleccionada", HOJA_CONTRATOS)

df_maestra = leer_excel(ARCHIVO_MAESTRA, sheet_name=HOJA_CONTRATOS)
LOG.success(f"Maestra cargada", f"{len(df_maestra):,} registros totales")

@dataclass
class ColumnasIdentificadas:
    tipo_proveedor: Optional[str] = None
    cto: Optional[str] = None
    numero_contrato: Optional[str] = None
    ano_contrato: Optional[str] = None

COLS = ColumnasIdentificadas()

for col in df_maestra.columns:
    col_upper = str(col).upper().strip()
    if 'TIPO' in col_upper and 'PROVEEDOR' in col_upper:
        COLS.tipo_proveedor = col
    elif col_upper == 'CTO':
        COLS.cto = col
    elif ('NUMERO' in col_upper or 'NÃšMERO' in col_upper) and 'CONTRATO' in col_upper:
        COLS.numero_contrato = col
    elif ('AÃ‘O' in col_upper or 'ANO' in col_upper) and 'CONTRATO' in col_upper:
        COLS.ano_contrato = col

LOG.info("Columnas identificadas:")
LOG.indent()
if COLS.tipo_proveedor: LOG.info("Tipo proveedor", COLS.tipo_proveedor)
if COLS.numero_contrato: LOG.info("NÃºmero contrato", COLS.numero_contrato)
if COLS.ano_contrato: LOG.info("AÃ±o contrato", COLS.ano_contrato)
if COLS.cto: LOG.info("CTO", COLS.cto)
LOG.dedent()

# ğŸ†• v14.1: MOSTRAR FILTROS APLICADOS
print("\n" + "â”€" * 50)
print("ğŸ“‹ FILTROS APLICADOS A LA MAESTRA:")
print("â”€" * 50)

registros_iniciales = len(df_maestra)
print(f"   â€¢ Registros iniciales: {registros_iniciales:,}")

if COLS.tipo_proveedor:
    tipos_unicos = df_maestra[COLS.tipo_proveedor].dropna().unique()
    print(f"\n   ğŸ“Œ FILTRO 1: Columna '{COLS.tipo_proveedor}'")
    print(f"      Valores encontrados: {list(tipos_unicos)[:5]}...")
    print(f"      Filtrando por: 'PRESTADOR DE SERVICIOS DE SALUD'")

    df_prestadores = df_maestra[
        df_maestra[COLS.tipo_proveedor] == 'PRESTADOR DE SERVICIOS DE SALUD'
    ].copy()

    registros_filtrados = len(df_prestadores)
    registros_excluidos = registros_iniciales - registros_filtrados
    print(f"      âœ… Registros despuÃ©s del filtro: {registros_filtrados:,}")
    print(f"      âŒ Registros excluidos: {registros_excluidos:,}")

    LOG.success(f"Prestadores filtrados", f"{len(df_prestadores):,} registros")
else:
    df_prestadores = df_maestra.copy()
    print(f"\n   âš ï¸ Sin columna TIPO PROVEEDOR - usando todos los registros")
    LOG.warning("Sin columna TIPO PROVEEDOR", "usando todos los registros")

if COLS.ano_contrato:
    anos = sorted([int(a) for a in df_prestadores[COLS.ano_contrato].dropna().unique()])
    print(f"\n   ğŸ“Œ AÃ‘OS DISPONIBLES EN LA MAESTRA:")
    print(f"      {anos}")

    print(f"\n   ğŸ“Š CONTRATOS POR AÃ‘O:")
    for ano in anos:
        count = len(df_prestadores[df_prestadores[COLS.ano_contrato] == ano])
        print(f"      â€¢ {ano}: {count:,} contratos")

    LOG.info("AÃ±os disponibles", str(anos))

print("â”€" * 50)
LOG.dedent()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CELDA 5: CLIENTE SFTP v14.1
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

LOG.step(4, 6, "CONFIGURANDO CLIENTE SFTP v14.1")
LOG.indent()

class SFTPClient:
    """ğŸ†• v14.1: Cliente SFTP con reconexiÃ³n forzada por contrato."""

    def __init__(self, config: Config, logger: Logger):
        self.config = config
        self.log = logger
        self._client = None
        self._sftp = None
        self._transport = None
        self._reconexiones = 0
        self._current_path = "/"

    def _cerrar(self):
        for c in [self._sftp, self._client]:
            try:
                if c: c.close()
            except: pass
        try:
            if self._transport:
                self._transport.close()
        except: pass
        self._sftp = self._client = self._transport = None

    def conectar(self, silencioso: bool = False) -> bool:
        self._cerrar()

        for intento in range(self.config.MAX_REINTENTOS_CONEXION):
            try:
                if not silencioso:
                    self.log.info(f"Conectando a {self.config.HOST}:{self.config.PORT}...")

                self._client = paramiko.SSHClient()
                self._client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                self._client.connect(
                    hostname=self.config.HOST,
                    port=self.config.PORT,
                    username=self.config.USERNAME,
                    password=self.config.PASSWORD,
                    timeout=self.config.TIMEOUT_CONEXION,
                    banner_timeout=self.config.TIMEOUT_CONEXION,
                    auth_timeout=self.config.TIMEOUT_CONEXION,
                    allow_agent=False,
                    look_for_keys=False
                )

                self._transport = self._client.get_transport()
                self._transport.set_keepalive(self.config.KEEPALIVE_INTERVAL)
                self._sftp = self._client.open_sftp()
                self._sftp.get_channel().settimeout(self.config.TIMEOUT_OPERACION)
                self._current_path = "/"

                if not silencioso:
                    self.log.success("ConexiÃ³n establecida")
                return True

            except Exception as e:
                self._cerrar()
                if intento < self.config.MAX_REINTENTOS_CONEXION - 1:
                    espera = self.config.BACKOFF_BASE ** intento
                    if not silencioso:
                        self.log.warning(f"Intento {intento + 1} fallido", f"reintentando en {espera:.1f}s")
                    time.sleep(espera)

        if not silencioso:
            self.log.error("No se pudo conectar despuÃ©s de varios intentos")
        return False

    def reconectar_forzado(self, silencioso: bool = True) -> bool:
        """ğŸ†• v14.1: Fuerza reconexiÃ³n."""
        self._reconexiones += 1
        self._cerrar()
        time.sleep(0.5)
        return self.conectar(silencioso)

    def esta_activo(self) -> bool:
        try:
            if not self._sftp or not self._transport: return False
            if not self._transport.is_active(): return False
            self._sftp.getcwd()
            return True
        except:
            return False

    def _ejecutar(self, operacion: Callable, descripcion: str = "operaciÃ³n"):
        for intento in range(self.config.MAX_REINTENTOS_OPERACION):
            try:
                if not self.esta_activo():
                    self._reconexiones += 1
                    self.log.warning("Reconectando...", f"intento {self._reconexiones}")
                    if not self.conectar(True):
                        raise Exception("ReconexiÃ³n fallida")
                return operacion()
            except Exception as e:
                if intento == self.config.MAX_REINTENTOS_OPERACION - 1:
                    raise
                time.sleep(1)

    def listar(self, ruta: str = '.') -> List[Dict]:
        def _op():
            return [
                {
                    'nombre': a.filename,
                    'tamano': a.st_size,
                    'es_directorio': stat.S_ISDIR(a.st_mode),
                    'fecha_modificacion': a.st_mtime
                }
                for a in self._sftp.listdir_attr(ruta)
            ]
        return self._ejecutar(_op)

    def cd(self, ruta: str, log_nav: bool = True):
        def _op():
            self._sftp.chdir(ruta)
            self._current_path = self._sftp.getcwd() or ruta
        self._ejecutar(_op)
        if log_nav:
            self.log.nav(self._current_path)

    def descargar(self, remoto: str, local: str, log_download: bool = True):
        if log_download:
            self.log.download(remoto)
        self._ejecutar(lambda: self._sftp.get(remoto, local))

    def desconectar(self):
        self._cerrar()
        self.log.info("ConexiÃ³n SFTP cerrada")

    @property
    def path_actual(self) -> str:
        return self._current_path

    @property
    def reconexiones(self) -> int:
        return self._reconexiones

LOG.success("Cliente SFTP v14.1 configurado")
LOG.success("ğŸ†• ReconexiÃ³n forzada por contrato habilitada")
LOG.dedent()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CELDA 6: BUSCADOR DE ANEXOS v14.1
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

LOG.step(5, 6, "CONFIGURANDO BUSCADOR DE ANEXOS v14.1")
LOG.indent()

class BuscadorAnexos:
    """ğŸ†• v14.1: Buscador de anexos con bÃºsqueda mejorada."""

    def __init__(self, cliente: SFTPClient, config: Config, logger: Logger):
        self.cliente = cliente
        self.config = config
        self.log = logger
        self.alertas: List[Alerta] = []
        self._contrato_actual = ""

    def limpiar_alertas(self):
        self.alertas = []

    def set_contrato(self, contrato: str):
        self._contrato_actual = contrato

    def agregar_alerta(self, tipo: TipoAlerta, mensaje: str, archivo: str = ""):
        self.alertas.append(Alerta(
            tipo=tipo,
            mensaje=mensaje,
            contrato=self._contrato_actual,
            archivo=archivo
        ))
        self.log.alert(tipo.value, mensaje, archivo)

    def extraer_numero_otrosi(self, nombre: str) -> Optional[int]:
        """ğŸ†• v15.0: Extrae nÃºmero de otrosÃ­ con patrones expandidos."""
        if not nombre:
            return None
        nombre_upper = nombre.upper()

        # Patrones expandidos v15.0
        patrones = [
            r'OTRO\s*S[IÃ]\s*[_#\-\s]*N?[OÃšÂºÂ°]?\.?\s*(\d+)',
            r'OTROS[IÃ]\s*[_#\-\s]*(\d+)',
            r'OTRO[\s_\-]?SI[\s_\-#]*(\d+)',
            r'OT\s*[_\-\s]?\s*(\d+)',
            r'ADICI[OÃ“]N\s*[_#\-\s]*N?[OÃšÂºÂ°]?\.?\s*(\d+)',
            r'MODIFICA(?:CI[OÃ“]N)?\s*[_#\-\s]*(\d+)',
        ]

        for patron in patrones:
            match = re.search(patron, nombre_upper)
            if match:
                try:
                    return int(match.group(1))
                except (ValueError, IndexError):
                    continue
        return None

    def extraer_numero_acta(self, nombre: str, nombre_carpeta: str = None) -> Optional[int]:
        """ğŸ†• v14.1: Extrae nÃºmero de acta del nombre o carpeta."""
        if not nombre:
            nombre = ""

        nombre_upper = nombre.upper()

        patrones = [
            r'ACTA\s*(?:DE\s*)?(?:NEGOCIACI[OÃ“]N\s*)?(?:N[OÃšÂºÂ°]?\.?\s*)?#?\s*(\d+)',
            r'ACT[_\-\s]?(\d+)',
            r'\bAN\s*[_\-]?\s*(\d+)',
            r'ACTA\s*#?\s*(\d+)',
            r'ACTA\s*N[OÃšÂºÂ°]?\s*(\d+)',
        ]

        for patron in patrones:
            match = re.search(patron, nombre_upper)
            if match:
                return int(match.group(1))

        if nombre_carpeta:
            carpeta_upper = nombre_carpeta.upper()
            for patron in patrones:
                match = re.search(patron, carpeta_upper)
                if match:
                    return int(match.group(1))

        return None

    def buscar_carpeta(self, carpetas: List[str], texto: str) -> Optional[str]:
        texto_l = texto.lower()
        for c in carpetas:
            if c.lower() == texto_l: return c
        for c in carpetas:
            if texto_l in c.lower(): return c
        return None

    def buscar_carpeta_contrato(self, carpetas: List[str], numero: str, nombre_proveedor: str = None) -> Optional[str]:
        """ğŸ†• v14.1: BÃºsqueda mejorada con cero inicial."""
        num = ''.join(filter(str.isdigit, str(numero)))

        variantes = [
            num,
            num.zfill(4),
            num.zfill(3),
            num.zfill(5),
            num.lstrip('0') or '0',
            '0' + num,
        ]

        variantes_unicas = list(dict.fromkeys(variantes))

        self.log.debug(f"Buscando contrato con variantes: {variantes_unicas}")

        for variante in variantes_unicas:
            for carpeta in carpetas:
                partes = re.split(r'[\s\-_]', carpeta)
                if partes and partes[0] == variante:
                    self.log.debug(f"Encontrado con variante '{variante}': {carpeta}")
                    return carpeta

        for variante in variantes_unicas:
            for carpeta in carpetas:
                if carpeta.startswith(variante + '-') or carpeta.startswith(variante + '_') or carpeta.startswith(variante + ' '):
                    self.log.debug(f"Encontrado por prefijo '{variante}': {carpeta}")
                    return carpeta

        if nombre_proveedor:
            nombre_limpio = nombre_proveedor.upper().strip()
            for carpeta in carpetas:
                if nombre_limpio in carpeta.upper():
                    self.log.debug(f"Encontrado por nombre proveedor: {carpeta}")
                    return carpeta

        return None

    def navegar_a_contrato(self, ano: str, numero: str, nombre_proveedor: str = None) -> Tuple[bool, str, Optional[str]]:
        """ğŸ†• v14.1: Navega con bÃºsqueda mejorada."""
        try:
            self.log.info("Navegando a contrato...")
            self.log.indent()

            self.cliente.cd('/', log_nav=False)
            items = self.cliente.listar()
            carpetas = [i['nombre'] for i in items if i['es_directorio']]

            cp = self.buscar_carpeta(carpetas, self.config.CARPETA_PRINCIPAL)
            if not cp:
                self.log.error("No encontrada", "carpeta principal")
                self.log.dedent()
                return False, "Sin carpeta principal", None

            self.cliente.cd(cp)

            items = self.cliente.listar()
            carpetas = [i['nombre'] for i in items if i['es_directorio']]
            ca = self.buscar_carpeta(carpetas, f'contratos {ano}')
            if not ca:
                self.log.error("No encontrada", f"carpeta aÃ±o {ano}")
                self.log.dedent()
                return False, f"Sin aÃ±o {ano}", None

            self.cliente.cd(ca)

            items = self.cliente.listar()
            carpetas = [i['nombre'] for i in items if i['es_directorio']]

            cc = self.buscar_carpeta_contrato(carpetas, numero, nombre_proveedor)

            if not cc:
                self.log.error("No encontrada", f"carpeta contrato {numero}")
                self.log.warning("ğŸ†• Variantes buscadas", f"{numero}, 0{numero}, {numero.zfill(4)}")
                self.log.nav_tree(carpetas[:10], "carpetas")

                self.agregar_alerta(
                    TipoAlerta.CONTRATO_NO_ENCONTRADO_GO,
                    f"CONTRATO NO SE ENCUENTRA EN EL GO ANYWHERE. Buscado: {numero}, 0{numero}, {numero.zfill(4)}"
                )

                self.log.dedent()
                return False, f"CONTRATO NO SE ENCUENTRA EN EL GO ANYWHERE", None

            self.cliente.cd(cc)
            self.log.success("Contrato encontrado", cc)
            self.log.dedent()

            return True, "OK", f"/{cp}/{ca}/{cc}"

        except Exception as e:
            self.log.error("Error de navegaciÃ³n", str(e)[:40])
            self.log.dedent()
            return False, str(e)[:40], None

    def descargar_anexos(self, carpeta_destino: str, id_contrato: str) -> Dict:
        """Descarga ANEXO 1 con logging detallado."""
        resultado = {
            'exito': False,
            'archivos': [],
            'mensaje': '',
            'actas_encontradas': [],
            'otrosis_encontrados': []
        }

        try:
            self.log.info("Buscando archivos ANEXO 1...")
            self.log.indent()

            items = self.cliente.listar()
            carpetas = [i['nombre'] for i in items if i['es_directorio']]
            archivos = [i['nombre'] for i in items if not i['es_directorio']]

            self.log.debug(f"Contenido: {len(carpetas)} carpetas, {len(archivos)} archivos")

            carpeta_tarifas = None
            for c in carpetas:
                if 'tarifa' in c.lower():
                    carpeta_tarifas = c
                    break

            if not carpeta_tarifas:
                self.log.error("Carpeta TARIFAS no encontrada")
                self.log.nav_tree(carpetas, "carpetas")
                self.agregar_alerta(TipoAlerta.SIN_CARPETA_TARIFAS, "No existe carpeta TARIFAS")
                self.log.dedent()
                resultado['mensaje'] = "Sin TARIFAS"
                return resultado

            self.cliente.cd(carpeta_tarifas)
            items_tarifas = self.cliente.listar()

            archivos_excel = [i for i in items_tarifas if not i['es_directorio'] and es_extension_excel(i['nombre'])]
            subcarpetas = [i for i in items_tarifas if i['es_directorio']]

            self.log.info(f"En TARIFAS: {len(archivos_excel)} Excel, {len(subcarpetas)} subcarpetas")

            anexos_iniciales = []
            anexos_otrosi = []
            archivos_ignorados = []

            # ğŸ†• v15.0: Usar clasificar_tipo_archivo para mejor detecciÃ³n
            for item in archivos_excel:
                nombre = item['nombre']

                # Clasificar el archivo
                info = clasificar_tipo_archivo(nombre)

                if not info['es_valido']:
                    archivos_ignorados.append((nombre, info.get('motivo_exclusion', 'N/A')))
                    self.log.debug(f"Archivo ignorado: {nombre} ({info.get('motivo_exclusion', 'N/A')})")
                    continue

                self.log.debug(f"âœ“ Archivo vÃ¡lido: {nombre} â†’ tipo={info['tipo']}")

                num_otrosi = self.extraer_numero_otrosi(nombre)
                if num_otrosi:
                    anexos_otrosi.append({'item': item, 'numero': num_otrosi, 'tipo': info['tipo']})
                    self.log.file_found(nombre, f"OtrosÃ­ {num_otrosi} ({info['tipo']})")
                else:
                    anexos_iniciales.append({'item': item, 'tipo': info['tipo']})
                    self.log.file_found(nombre, f"Inicial ({info['tipo']})")

            if archivos_ignorados and len(archivos_ignorados) <= 5:
                for nombre_ign, motivo in archivos_ignorados:
                    self.log.debug(f"  â†³ Ignorado: {nombre_ign[:40]}... - {motivo}")

            resultado['otrosis_encontrados'] = [a['numero'] for a in anexos_otrosi]

            archivo_principal = None
            origen_principal = None
            numero_principal = None
            fecha_referencia = None

            if anexos_otrosi:
                anexos_otrosi.sort(key=lambda x: x['numero'], reverse=True)
                archivo_principal = anexos_otrosi[0]['item']
                numero_principal = anexos_otrosi[0]['numero']
                origen_principal = OrigenTarifa.OTROSI
                self.log.info(f"Seleccionado: OtrosÃ­ {numero_principal} (mayor)")
            elif anexos_iniciales:
                archivo_principal = anexos_iniciales[0]['item']
                origen_principal = OrigenTarifa.INICIAL
                self.log.info("Seleccionado: Anexo inicial")
            else:
                self.log.warning("No hay ANEXO 1 ni TARIFAS en carpeta")
                msg_extra = ""
                if archivos_ignorados:
                    nombres_ignorados = [n for n, m in archivos_ignorados[:3]]
                    msg_extra = f" | Archivos ignorados: {', '.join(nombres_ignorados)}"
                self.agregar_alerta(TipoAlerta.SIN_ANEXO1, f"No hay anexo 1, otrosÃ­ ni archivo TARIFAS vÃ¡lido{msg_extra}")
                resultado['mensaje'] = "Sin ANEXO 1"

            if archivo_principal:
                ruta_local = os.path.join(carpeta_destino, archivo_principal['nombre'])
                self.cliente.descargar(archivo_principal['nombre'], ruta_local)
                fecha_referencia = archivo_principal.get('fecha_modificacion')
                resultado['archivos'].append(ArchivoAnexo(
                    nombre=archivo_principal['nombre'],
                    ruta_local=ruta_local,
                    origen=origen_principal,
                    numero=numero_principal,
                    fecha_modificacion=fecha_referencia,
                    origen_completo=f"/{carpeta_tarifas}/{archivo_principal['nombre']}"
                ))

            carpetas_actas = [item for item in subcarpetas if 'acta' in item['nombre'].lower()]

            if carpetas_actas:
                self.log.info(f"Buscando en {len(carpetas_actas)} carpeta(s) de actas...")

            todas_las_actas = []

            for carpeta_acta in carpetas_actas:
                try:
                    self.cliente.cd(carpeta_acta['nombre'], log_nav=False)
                    self.log.debug(f"Entrando a: {carpeta_acta['nombre']}")

                    items_actas = self.cliente.listar()
                    actas_excel = [i for i in items_actas if not i['es_directorio'] and es_extension_excel(i['nombre'])]
                    actas_en_carpeta = []

                    for ia in actas_excel:
                        if not contiene_anexo1(ia['nombre']):
                            continue

                        num_acta = self.extraer_numero_acta(ia['nombre'], carpeta_acta['nombre'])
                        fecha_acta = ia.get('fecha_modificacion')

                        descargar = False
                        if not archivo_principal:
                            descargar = True
                        elif fecha_referencia and fecha_acta and fecha_acta > fecha_referencia:
                            descargar = True

                        if descargar:
                            nombre_local = f"ACTA_{carpeta_acta['nombre']}_{ia['nombre']}"
                            nombre_local = re.sub(r'[<>:"/\\|?*]', '_', nombre_local)
                            ruta_acta = os.path.join(carpeta_destino, nombre_local)
                            self.cliente.descargar(ia['nombre'], ruta_acta, log_download=False)
                            self.log.file_found(ia['nombre'], f"Acta {num_acta or '?'}")

                            resultado['archivos'].append(ArchivoAnexo(
                                nombre=nombre_local,
                                ruta_local=ruta_acta,
                                origen=OrigenTarifa.ACTA,
                                numero=num_acta,
                                fecha_modificacion=fecha_acta,
                                origen_completo=f"/{carpeta_tarifas}/{carpeta_acta['nombre']}/{ia['nombre']}"
                            ))

                        if num_acta:
                            actas_en_carpeta.append(num_acta)
                            todas_las_actas.append(num_acta)

                    if not actas_en_carpeta and actas_excel:
                        self.log.warning(f"Carpeta '{carpeta_acta['nombre']}' sin ANEXO 1")
                        self.agregar_alerta(
                            TipoAlerta.CARPETA_ACTAS_SIN_ANEXO,
                            f"Carpeta sin anexo 1",
                            carpeta_acta['nombre']
                        )

                    self.cliente.cd('..', log_nav=False)

                except Exception as e_acta:
                    self.log.error(f"Error en carpeta actas", str(e_acta)[:30])
                    self.agregar_alerta(
                        TipoAlerta.ERROR_PROCESAMIENTO,
                        f"Error procesando: {str(e_acta)[:30]}",
                        carpeta_acta['nombre']
                    )
                    try:
                        self.cliente.cd('..', log_nav=False)
                    except:
                        pass

            resultado['actas_encontradas'] = sorted(set(todas_las_actas))

            if todas_las_actas:
                max_acta = max(todas_las_actas)
                faltantes = [i for i in range(1, max_acta + 1) if i not in todas_las_actas]
                for f in faltantes:
                    self.log.warning(f"Acta {f} faltante en secuencia")
                    self.agregar_alerta(TipoAlerta.ACTA_FALTANTE, f"Falta anexo 1 del acta {f}")

            if resultado['archivos']:
                resultado['exito'] = True
                resultado['mensaje'] = f"{len(resultado['archivos'])} archivo(s)"
                self.log.success(f"Total archivos a procesar: {len(resultado['archivos'])}")

            self.log.dedent()
            return resultado

        except Exception as e:
            self.log.error("Error en descarga", str(e)[:40])
            self.agregar_alerta(TipoAlerta.ERROR_PROCESAMIENTO, str(e)[:50])
            self.log.dedent()
            resultado['mensaje'] = str(e)[:40]
            return resultado

LOG.success("Buscador de anexos v14.1 configurado")
LOG.success("ğŸ†• BÃºsqueda con cero inicial habilitada")
LOG.dedent()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CELDA 7: PROCESADOR DE ANEXOS v14.1
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

LOG.step(6, 6, "CONFIGURANDO PROCESADOR DE ANEXOS v14.1")
LOG.indent()

class ProcesadorAnexo:
    """ğŸ†• v14.1: Procesador de anexos con detecciÃ³n de columnas mejorada."""

    def __init__(self, logger: Logger):
        self.log = logger
        self._alertas_set: set = set()
        self.alertas: List[Alerta] = []
        self._contrato_actual = ""
        self._categoria_cuentas_medicas = ""

    def limpiar_alertas(self):
        self._alertas_set = set()
        self.alertas = []

    def set_contrato(self, contrato: str):
        self._contrato_actual = contrato

    def set_categoria_cuentas_medicas(self, categoria: str):
        self._categoria_cuentas_medicas = categoria if categoria else ""

    def agregar_alerta(self, tipo: TipoAlerta, mensaje: str, archivo: str = ""):
        nueva_alerta = Alerta(
            tipo=tipo,
            mensaje=mensaje,
            contrato=self._contrato_actual,
            archivo=archivo
        )

        clave = (tipo, mensaje, self._contrato_actual, archivo)
        if clave not in self._alertas_set:
            self._alertas_set.add(clave)
            self.alertas.append(nueva_alerta)
            self.log.alert(tipo.value, mensaje, archivo)

    def buscar_hoja_servicios(self, archivo: str) -> Optional[str]:
        """ğŸ†• v14.1: Busca la hoja de servicios - CORREGIDO.
        Las hojas de PAQUETES NO generan alerta individual, solo se mencionan
        si no hay hoja de servicios vÃ¡lida.
        """
        formato_real = detectar_formato_real(archivo)
        ext_declarada = os.path.splitext(archivo)[1].lower()

        if formato_real == 'xlsb' and ext_declarada != '.xlsb':
            self.log.debug(f"âš ï¸ Formato real: XLSB (extensiÃ³n: {ext_declarada})")

        hojas = obtener_hojas(archivo)

        if not hojas:
            motivo = f"No se pudo leer archivo (formato: {formato_real})"
            self.agregar_alerta(TipoAlerta.ERROR_LECTURA, motivo, os.path.basename(archivo))
            return None

        # ğŸ†• v14.1: Usar nueva funciÃ³n que retorna info de hojas excluidas
        hoja_encontrada, hojas_excluidas_info = buscar_hoja_servicios_inteligente(hojas)

        if hoja_encontrada:
            # âœ… EncontrÃ³ hoja de servicios - NO genera alerta de PAQUETES
            self.log.debug(f"Hoja seleccionada: '{hoja_encontrada}' de {len(hojas)} disponibles")
            return hoja_encontrada

        # âŒ NO encontrÃ³ hoja de servicios - verificar tipo de archivo
        es_solo_traslados, msg_traslados, tipo_archivo = es_archivo_solo_traslados(hojas)

        if es_solo_traslados:
            self.log.warning(f"Archivo de {tipo_archivo.lower()}", msg_traslados)

            if tipo_archivo == "AMBULANCIAS":
                self.agregar_alerta(
                    TipoAlerta.ARCHIVO_SOLO_AMBULANCIAS,
                    msg_traslados,
                    os.path.basename(archivo)
                )
            elif tipo_archivo == "TRASLADOS":
                self.agregar_alerta(
                    TipoAlerta.ARCHIVO_SOLO_TRASLADOS,
                    msg_traslados,
                    os.path.basename(archivo)
                )
            else:
                self.agregar_alerta(
                    TipoAlerta.SOLO_TRASLADOS,
                    msg_traslados,
                    os.path.basename(archivo)
                )
            return None

        # ğŸ†• v14.1: Generar mensaje con TODAS las hojas disponibles
        # AQUÃ es donde se mencionan las hojas de PAQUETES (no antes)
        hojas_str = ", ".join([f"'{h}'" for h in hojas])
        mensaje = f"No se encontrÃ³ hoja de servicios vÃ¡lida. Hojas disponibles: [{hojas_str}]"

        # Agregar info de hojas excluidas si existen (PAQUETES, COSTO VIAJE)
        if hojas_excluidas_info:
            excluidas_str = ", ".join([f"'{h[0]}'" for h in hojas_excluidas_info])
            mensaje += f". Hojas excluidas (no aplican para T25): [{excluidas_str}]"

        if self._categoria_cuentas_medicas:
            mensaje += f". CategorÃ­a cuentas mÃ©dicas: '{self._categoria_cuentas_medicas}'"

        self.agregar_alerta(TipoAlerta.HOJA_NO_ENCONTRADA, mensaje, os.path.basename(archivo))

        return None

    def detectar_columnas(self, fila: List) -> Dict[str, int]:
        """ğŸ†• v14.1: Detecta Ã­ndices de columnas con prioridad estricta."""
        idx = {
            'cups': -1,
            'homologo': -1,
            'descripcion': -1,
            'tarifa': -1,
            'tarifario': -1,
            'porcentaje': -1,
            'observaciones': -1
        }

        columnas_usadas = set()

        PATRONES_ORDENADOS = [
            ('cups', [
                'CODIGO CUPS', 'CÃ“DIGO CUPS', 'COD CUPS', 'COD. CUPS',
                'CODIGO CUP', 'COD CUP', 'COD. CUP'
            ]),
            ('homologo', [
                'CODIGO HOMOLOGO', 'CÃ“DIGO HOMÃ“LOGO', 'COD HOMOLOGO',
                'HOMOLOGO MANUAL', 'CÃ“DIGO HOMOLOGO MANUAL', 'CODIGO HOMOLOGO MANUAL'
            ]),
            ('descripcion', [
                'DESCRIPCION DEL CUPS', 'DESCRIPCIÃ“N DEL CUPS',
                'DESCRIPCION CUPS', 'DESCRIPCIÃ“N CUPS',
                'DESCRIPCION DEL CUP', 'DESCRIPCIÃ“N DEL CUP'
            ]),
            ('tarifa', [
                'TARIFA UNITARIA EN PESOS', 'TARIFA UNITARIA PESOS',
                'TARIFA EN PESOS', 'TARIFA UNITARIA',
                'VALOR UNITARIO', 'PRECIO UNITARIO'
            ]),
            ('tarifario', [
                'MANUAL TARIFARIO', 'TARIFARIO', 'MANUAL TAR',
                'TIPO TARIFARIO', 'TIPO DE TARIFARIO'
            ]),
            ('porcentaje', [
                'TARIFA SEGUN TARIFARIO', 'TARIFA SEGÃšN TARIFARIO',
                'PORCENTAJE TARIFARIO', 'PORCENTAJE',
                '% TARIFARIO', '% DEL TARIFARIO'
            ]),
            ('observaciones', [
                'OBSERVACIONES', 'OBSERVACION', 'OBS', 'NOTAS'
            ]),
        ]

        for i, celda in enumerate(fila):
            t = normalizar_texto(celda)
            if not t:
                continue

            if i in columnas_usadas:
                continue

            for campo, patrones in PATRONES_ORDENADOS:
                if idx[campo] != -1:
                    continue

                for patron in patrones:
                    patron_norm = normalizar_texto(patron)

                    if patron_norm in t or patron_norm == t:
                        if campo == 'cups' and 'HOMOLOGO' in t:
                            continue

                        if campo == 'tarifa':
                            if 'TARIFARIO' in t or 'SEGUN' in t or 'SEGÃšN' in t:
                                continue
                            if 'MANUAL' in t and 'UNITARIA' not in t:
                                continue

                        if campo == 'tarifario':
                            if 'UNITARIA' in t or 'EN PESOS' in t or 'PESOS' in t:
                                continue

                        if campo == 'porcentaje':
                            if 'UNITARIA' in t:
                                continue

                        idx[campo] = i
                        columnas_usadas.add(i)
                        break

                if idx[campo] != -1:
                    break

        return idx

    def extraer_sedes_de_bloque(self, datos: List[List], inicio: int, idx_hab: int, idx_sede: int) -> List[Dict]:
        """Extrae las sedes de un bloque de datos de sedes."""
        sedes = []
        k = inicio

        while k < len(datos) and len(sedes) < CONFIG.MAX_SEDES:
            fila = datos[k]
            if not fila:
                k += 1
                continue

            if es_encabezado_seccion_sedes(fila) or es_encabezado_seccion_servicios(fila):
                break

            if es_dato_de_sede(fila):
                if idx_hab >= 0 and idx_hab < len(fila):
                    codigo_hab = fila[idx_hab]
                    if codigo_hab:
                        codigo_str = str(codigo_hab).strip()
                        if codigo_str.endswith('.0'):
                            codigo_str = codigo_str[:-2]
                        codigo_clean = re.sub(r'[^\d]', '', codigo_str)

                        if codigo_clean and codigo_clean.isdigit() and 5 <= len(codigo_clean) <= 12:
                            num_sede = fila[idx_sede] if idx_sede >= 0 and idx_sede < len(fila) else len(sedes) + 1
                            sedes.append({'codigo': codigo_hab, 'sede': num_sede})
                            k += 1
                            continue

            if fila[0] is not None:
                primera = str(fila[0]).upper().strip()
                if not es_municipio_o_departamento(primera) and not es_direccion(primera):
                    if primera and not primera.isspace():
                        break

            k += 1

        return sedes

    def extraer_servicios(self, archivo: str, nombre: str) -> Tuple[bool, List[Dict], str]:
        """Extrae servicios del archivo ANEXO 1."""
        try:
            self.log.process(f"Procesando: {nombre[:50]}...")
            self.log.indent()

            hoja = self.buscar_hoja_servicios(archivo)
            if not hoja:
                self.log.error("No se encontrÃ³ hoja de servicios")
                self.log.dedent()
                return False, [], "Sin hoja de servicios"

            formato = detectar_formato_real(archivo)
            self.log.info(f"Hoja encontrada: '{hoja}' (formato: {formato})")

            datos = leer_hoja_raw(archivo, hoja, max_filas=20000)
            if not datos:
                self.log.error("Hoja vacÃ­a o no legible")
                self.agregar_alerta(TipoAlerta.ERROR_LECTURA, "Hoja vacÃ­a", nombre)
                self.log.dedent()
                return False, [], "Hoja vacÃ­a"

            self.log.debug(f"Filas leÃ­das: {len(datos)}")

            servicios = []
            sedes_activas = []
            idx_columnas = None
            encontro_encabezado_servicios = False
            encontro_sedes = False

            estado = 'buscando'

            i = 0
            while i < len(datos):
                fila = datos[i]

                if not fila or all(c is None for c in fila):
                    i += 1
                    continue

                if es_encabezado_seccion_sedes(fila):
                    self.log.debug(f"Fila {i+1}: Encabezado de SEDES detectado")
                    encontro_sedes = True
                    estado = 'en_sedes'

                    idx_hab = -1
                    idx_sede = -1
                    for j, c in enumerate(fila):
                        t = normalizar_texto(c) if c else ''
                        if 'HABILITACION' in t or 'HABIITACION' in t:
                            idx_hab = j
                        if 'NUMERO DE SEDE' in t or 'NUMERO SEDE' in t or 'N SEDE' in t or 'NÂ° SEDE' in t:
                            idx_sede = j

                    if idx_sede == -1 and idx_hab >= 0:
                        idx_sede = idx_hab + 1

                    nuevas_sedes = self.extraer_sedes_de_bloque(datos, i + 1, idx_hab, idx_sede)
                    if nuevas_sedes:
                        sedes_activas = nuevas_sedes
                        self.log.debug(f"  Sedes extraÃ­das: {len(sedes_activas)}")

                    i += 1
                    continue

                if es_encabezado_seccion_servicios(fila):
                    self.log.debug(f"Fila {i+1}: Encabezado de SERVICIOS detectado")
                    idx_columnas = self.detectar_columnas(fila)
                    encontro_encabezado_servicios = True
                    estado = 'en_servicios'

                    cols_detectadas = [k for k, v in idx_columnas.items() if v >= 0]
                    self.log.debug(f"  Columnas: {cols_detectadas}")

                    i += 1
                    continue

                if estado == 'en_sedes':
                    if es_dato_de_sede(fila):
                        i += 1
                        continue
                    i += 1
                    continue

                if estado == 'en_servicios' and idx_columnas and sedes_activas:
                    if es_dato_de_sede(fila):
                        self.log.debug(f"Fila {i+1}: Saltando (es dato de sede)")
                        i += 1
                        continue

                    if idx_columnas['cups'] >= 0 and idx_columnas['cups'] < len(fila):
                        cups_raw = fila[idx_columnas['cups']]
                        cups = limpiar_codigo(cups_raw)

                        if cups and validar_cups(cups, fila):
                            def get_valor(campo: str):
                                col_idx = idx_columnas.get(campo, -1)
                                return fila[col_idx] if 0 <= col_idx < len(fila) else None

                            tarifa = get_valor('tarifa')
                            manual = get_valor('tarifario')
                            descripcion = get_valor('descripcion')

                            if not validar_tarifa(tarifa):
                                self.log.debug(f"Fila {i+1}: Tarifa rechazada (parece telÃ©fono)")
                                i += 1
                                continue

                            if not validar_manual_tarifario(manual):
                                self.log.debug(f"Fila {i+1}: Manual rechazado (parece direcciÃ³n)")
                                i += 1
                                continue

                            if not validar_descripcion(descripcion):
                                self.log.debug(f"Fila {i+1}: DescripciÃ³n rechazada (es nÃºmero de sede)")
                                i += 1
                                continue

                            base = {
                                'codigo_cups': cups,
                                'codigo_homologo_manual': limpiar_codigo(get_valor('homologo')),
                                'descripcion_del_cups': limpiar_texto(descripcion),
                                'tarifa_unitaria_en_pesos': limpiar_tarifa(tarifa),
                                'manual_tarifario': limpiar_texto(manual),
                                'porcentaje_manual_tarifario': limpiar_texto(get_valor('porcentaje')),
                                'observaciones': limpiar_texto(get_valor('observaciones'))
                            }

                            for sede in sedes_activas:
                                s = base.copy()
                                s['codigo_de_habilitacion'] = formatear_habilitacion(sede['codigo'], sede['sede'])
                                servicios.append(s)

                i += 1

            if not encontro_encabezado_servicios:
                self.log.warning("No se encontrÃ³ encabezado de servicios")
                self.agregar_alerta(TipoAlerta.COLUMNAS_NO_DETECTADAS, "Sin encabezado de servicios", nombre)

            if not encontro_sedes:
                self.log.warning("No se encontrÃ³ secciÃ³n de sedes")
                self.agregar_alerta(TipoAlerta.SEDES_NO_DETECTADAS, "Sin secciÃ³n de sedes", nombre)

            if servicios:
                self.log.success(f"Servicios extraÃ­dos: {len(servicios):,}")
                self.log.dedent()
                return True, servicios, f"{len(servicios)} servicios"
            else:
                self.log.warning("No se extrajeron servicios")
                self.log.dedent()
                return False, [], "Sin servicios extraÃ­dos"

        except Exception as e:
            self.log.error(f"Error procesando archivo: {str(e)[:50]}")
            self.agregar_alerta(TipoAlerta.ERROR_PROCESAMIENTO, str(e)[:50], nombre)
            self.log.dedent()
            return False, [], str(e)[:50]

    def extraer_con_timeout(self, archivo: str, nombre: str, timeout: int = 60) -> Tuple[bool, List[Dict], str]:
        """Extrae servicios con timeout."""
        resultado = [False, [], "Timeout"]
        error_msg = [None]

        def worker():
            try:
                resultado[0], resultado[1], resultado[2] = self.extraer_servicios(archivo, nombre)
            except Exception as e:
                error_msg[0] = str(e)
                resultado[0] = False
                resultado[2] = str(e)[:50]

        thread = threading.Thread(target=worker)
        thread.start()
        thread.join(timeout)

        if thread.is_alive():
            self.log.warning(f"Timeout ({timeout}s) procesando archivo")
            self.agregar_alerta(TipoAlerta.TIMEOUT, f"Archivo tardÃ³ mÃ¡s de {timeout}s", nombre)
            return False, [], f"Timeout ({timeout}s)"

        if error_msg[0]:
            self.agregar_alerta(TipoAlerta.ERROR_PROCESAMIENTO, error_msg[0][:50], nombre)

        return resultado[0], resultado[1], resultado[2]


LOG.success("Procesador de anexos v14.1 configurado")
LOG.success("ğŸ†• DetecciÃ³n de columnas con prioridad estricta")
LOG.dedent()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CELDA 8: FUNCIÃ“N OBTENER FECHA DE ACUERDO
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def obtener_fecha_acuerdo(numero: str, ano: str, origen: str, fecha_archivo: float = None) -> Tuple[Optional[str], bool]:
    """Obtiene fecha de acuerdo de forma inteligente."""
    try:
        fila = None

        if COLS.cto:
            cto_str = f"{str(numero).zfill(4)}-{ano}"
            mask = df_prestadores[COLS.cto] == cto_str
            if mask.any():
                fila = df_prestadores[mask].iloc[0]

        if fila is None and COLS.numero_contrato and COLS.ano_contrato:
            try:
                mask = (
                    df_prestadores[COLS.numero_contrato].astype(str).str.replace('.0', '', regex=False).str.zfill(4) == str(numero).zfill(4)
                ) & (
                    df_prestadores[COLS.ano_contrato].astype(str).str.replace('.0', '', regex=False) == str(ano)
                )
                if mask.any():
                    fila = df_prestadores[mask].iloc[0]
            except:
                pass

        fecha = None
        columnas = list(df_prestadores.columns) if fila is not None else []

        if origen == 'Inicial' and fila is not None:
            for col in columnas:
                cl = str(col).lower()
                if 'fecha' in cl and 'inicial' in cl and 'otrosi' not in cl and 'otrosÃ­' not in cl:
                    fecha = fila[col]
                    break

        elif ('OtrosÃ­' in origen or 'Otrosi' in origen) and fila is not None:
            m = re.search(r'\d+', origen)
            if m:
                num = int(m.group())
                patron = f"fecha.*otros[iÃ­].*{num}"
                for col in columnas:
                    if re.search(patron, str(col).lower()):
                        fecha = fila[col]
                        break

        elif 'Acta' in origen and fila is not None:
            m = re.search(r'\d+', origen)
            if m:
                num = int(m.group())
                for i, col in enumerate(columnas):
                    cl = str(col).lower()
                    if 'no. acta' in cl or 'no acta' in cl:
                        val = fila[col]
                        if pd.notna(val):
                            ma = re.search(r'#?(\d+)', str(val))
                            if ma and int(ma.group(1)) == num:
                                if i + 1 < len(columnas):
                                    fecha = fila[columnas[i + 1]]
                                    break

        if fecha is None and fecha_archivo is not None:
            fecha_sftp = timestamp_a_fecha(fecha_archivo)
            if fecha_sftp:
                return fecha_sftp, True

        if fecha is not None and pd.notna(fecha):
            if isinstance(fecha, (int, float)):
                try:
                    dias = int(fecha)
                    if 30000 < dias < 60000:
                        fecha_dt = datetime(1899, 12, 30) + timedelta(days=dias)
                        return fecha_dt.strftime('%d/%m/%Y'), True
                except:
                    pass
            elif isinstance(fecha, datetime):
                return fecha.strftime('%d/%m/%Y'), True
            elif isinstance(fecha, str):
                fs = fecha.strip()
                if fs and fs.lower() not in ('nan', 'none', 'nat', ''):
                    return fs, True

        if fecha_archivo is not None:
            fecha_sftp = timestamp_a_fecha(fecha_archivo)
            if fecha_sftp:
                return fecha_sftp, True

        return None, False

    except Exception as e:
        if fecha_archivo is not None:
            fecha_sftp = timestamp_a_fecha(fecha_archivo)
            if fecha_sftp:
                return fecha_sftp, True
        return None, False

LOG.success("FunciÃ³n obtener_fecha_acuerdo cargada")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CELDA 9: GENERADOR DE EXCEL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from openpyxl import Workbook
from openpyxl.styles import Font, Alignment, PatternFill, Border, Side

MAX_FILAS_POR_HOJA = 1_000_000

def exportar_consolidado_multisheet(df: pd.DataFrame, nombre_base: str, log=None) -> str:
    """Exporta consolidado dividiendo en mÃºltiples hojas si es necesario."""
    timestamp = datetime.now().strftime('%Y%m%d_%H%M')
    archivo = f'{nombre_base}_{timestamp}.xlsx'

    def _log(msg, level='info'):
        if log:
            getattr(log, level, log.info)(msg)
        else:
            print(msg)

    total_filas = len(df)
    num_hojas = (total_filas // MAX_FILAS_POR_HOJA) + (1 if total_filas % MAX_FILAS_POR_HOJA > 0 else 0)

    _log(f'Exportando {total_filas:,} registros a {num_hojas} hoja(s)...')

    try:
        with pd.ExcelWriter(archivo, engine='openpyxl') as writer:
            for i in range(num_hojas):
                inicio = i * MAX_FILAS_POR_HOJA
                fin = min((i + 1) * MAX_FILAS_POR_HOJA, total_filas)
                registros_hoja = fin - inicio

                if num_hojas == 1:
                    hoja_nombre = 'CONSOLIDADO'
                else:
                    hoja_nombre = f'CONSOLIDADO_{i + 1}'

                _log(f'   ğŸ“Š Hoja \'{hoja_nombre}\': filas {inicio + 1:,} a {fin:,} ({registros_hoja:,} registros)')

                df.iloc[inicio:fin].to_excel(
                    writer,
                    sheet_name=hoja_nombre,
                    index=False,
                    freeze_panes=(1, 0)
                )

        tamaÃ±o = os.path.getsize(archivo)
        tamaÃ±o_str = f'{tamaÃ±o/1024/1024:.1f} MB' if tamaÃ±o > 1024*1024 else f'{tamaÃ±o/1024:.1f} KB'

        _log(f'âœ… Exportado: {archivo}')
        _log(f'   â€¢ TamaÃ±o: {tamaÃ±o_str}')
        _log(f'   â€¢ Hojas: {num_hojas}')
        _log(f'   â€¢ Total registros: {total_filas:,}')

        return archivo

    except Exception as e:
        _log(f'âŒ Error exportando: {str(e)}', 'error')
        raise


def exportar_consolidado_csv(df: pd.DataFrame, nombre_base: str, log=None) -> str:
    """Exporta consolidado a CSV."""
    timestamp = datetime.now().strftime('%Y%m%d_%H%M')
    archivo = f'{nombre_base}_{timestamp}.csv'

    df.to_csv(archivo, index=False, encoding='utf-8-sig')

    tamaÃ±o = os.path.getsize(archivo)
    tamaÃ±o_str = f'{tamaÃ±o/1024/1024:.1f} MB' if tamaÃ±o > 1024*1024 else f'{tamaÃ±o/1024:.1f} KB'

    if log:
        log.success(f'Exportado CSV: {archivo} ({tamaÃ±o_str}, {len(df):,} registros)')

    return archivo


LOG.success("Generador Excel cargado")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CELDA 10: SELECCIÃ“N DE CONTRATOS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

LOG.header("SELECCIÃ“N DE CONTRATOS")

print("""
  Opciones disponibles:
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  [1] Un contrato especÃ­fico
  [2] Todos los contratos de un aÃ±o
  [3] Todos los contratos
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
""")

opcion = input("â¤ OpciÃ³n (1/2/3): ").strip()

CONTRATOS_A_PROCESAR = []
MODO_OPERACION = ""
CARPETA_TRABAJO = "./trabajo"

LOG.indent()

if opcion == "1":
    MODO_OPERACION = "ESPECIFICO"
    numero = input("â¤ NÃºmero del contrato: ").strip()
    ano = input("â¤ AÃ±o del contrato: ").strip()
    CONTRATOS_A_PROCESAR = [{'numero': numero, 'ano': ano}]
    CARPETA_TRABAJO = f"./trabajo_{numero}_{ano}"
    LOG.success(f"Contrato seleccionado: {numero}-{ano}")

elif opcion == "2":
    MODO_OPERACION = "POR_ANO"
    if COLS.ano_contrato:
        anos = sorted([int(a) for a in df_prestadores[COLS.ano_contrato].dropna().unique()])
        print(f"   AÃ±os disponibles: {anos}")
    ano = input("â¤ AÃ±o a procesar: ").strip()

    if COLS.numero_contrato and COLS.ano_contrato:
        df_filtrado = df_prestadores[
            df_prestadores[COLS.ano_contrato].astype(str).str.replace('.0', '', regex=False) == ano
        ]
        for _, row in df_filtrado.iterrows():
            n = row[COLS.numero_contrato]
            if pd.notna(n):
                CONTRATOS_A_PROCESAR.append({'numero': str(int(n)), 'ano': ano})

    CARPETA_TRABAJO = f"./trabajo_ano_{ano}"
    LOG.success(f"AÃ±o seleccionado: {ano}", f"{len(CONTRATOS_A_PROCESAR)} contratos")

elif opcion == "3":
    MODO_OPERACION = "COMPLETO"
    if COLS.numero_contrato and COLS.ano_contrato:
        for _, row in df_prestadores.iterrows():
            n, a = row[COLS.numero_contrato], row[COLS.ano_contrato]
            if pd.notna(n) and pd.notna(a):
                CONTRATOS_A_PROCESAR.append({'numero': str(int(n)), 'ano': str(int(a))})
    CARPETA_TRABAJO = "./trabajo_completo"
    LOG.success(f"Procesamiento completo", f"{len(CONTRATOS_A_PROCESAR)} contratos")

else:
    LOG.error("OpciÃ³n no vÃ¡lida")

if CONTRATOS_A_PROCESAR:
    os.makedirs(CARPETA_TRABAJO, exist_ok=True)
    LOG.info("Carpeta de trabajo", CARPETA_TRABAJO)

LOG.dedent()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CELDA 11: CONEXIÃ“N AL SERVIDOR
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if CONTRATOS_A_PROCESAR:
    LOG.header("CONEXIÃ“N AL SERVIDOR SFTP")

    cliente = SFTPClient(CONFIG, LOG)

    if cliente.conectar():
        buscador = BuscadorAnexos(cliente, CONFIG, LOG)
        procesador = ProcesadorAnexo(LOG)

        LOG.info(f"Contratos a procesar: {len(CONTRATOS_A_PROCESAR)}")
        LOG.info(f"Timeout por archivo: {CONFIG.TIMEOUT_ARCHIVO}s")
    else:
        LOG.error("No se pudo conectar. Verifica la red y credenciales.")
else:
    LOG.warning("No hay contratos seleccionados")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CELDA 12: PROCESAMIENTO PRINCIPAL v14.1 - CON RECONEXIÃ“N FORZADA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if not CONTRATOS_A_PROCESAR:
    LOG.warning("No hay contratos para procesar")
else:
    LOG.header("PROCESAMIENTO v14.1", f"Modo: {MODO_OPERACION} | {len(CONTRATOS_A_PROCESAR)} contratos")

    LOG.start_time = time.time()
    LOG.stats = {
        'contratos_procesados': 0,
        'contratos_exitosos': 0,
        'archivos_descargados': 0,
        'servicios_extraidos': 0,
        'alertas_generadas': 0
    }

    consolidado_total = []
    todas_alertas = []
    alertas_set = set()
    resumen_contratos = []
    archivos_no_positiva = []
    contratos_sin_fecha = set()
    fechas_ok = fechas_no = 0

    PALABRAS_AMBULANCIA_MAESTRA = [
        'AMBULANCIA', 'AMBULANCIAS',
        'TRASLADO ASISTENCIAL', 'TRASLADOS ASISTENCIALES',
        'TAM', 'TAB',
        'TRANSPORTE ASISTENCIAL', 'TRANSPORTES ASISTENCIALES',
        'SERVICIO DE AMBULANCIA', 'SERVICIOS DE AMBULANCIA',
    ]

    COLUMNAS_REVISAR_AMBULANCIA = [
        'CATEGORÃA CUENTAS MEDICAS', 'CATEGORIA CUENTAS MEDICAS',
        'OBJETO', 'DESCRIPCION', 'DESCRIPCIÃ“N',
        'TIPO', 'TIPO_SERVICIO', 'SERVICIO'
    ]

    def detectar_ambulancia_en_maestra(numero: str, ano: str) -> Tuple[bool, str, str]:
        try:
            cto_str = f"{str(numero).zfill(4)}-{ano}"

            mask = None
            if COLS.cto:
                mask = df_maestra[COLS.cto] == cto_str

            if mask is None or not mask.any():
                if COLS.numero_contrato and COLS.ano_contrato:
                    mask = (
                        df_maestra[COLS.numero_contrato].astype(str).str.replace('.0', '', regex=False).str.zfill(4) == str(numero).zfill(4)
                    ) & (
                        df_maestra[COLS.ano_contrato].astype(str).str.replace('.0', '', regex=False) == str(ano)
                    )

            if mask is None or not mask.any():
                return False, "", ""

            fila_cto = df_maestra[mask].iloc[0]

            for col in df_maestra.columns:
                col_upper = str(col).upper().strip()

                revisar = False
                for col_target in COLUMNAS_REVISAR_AMBULANCIA:
                    if col_target in col_upper or col_upper in col_target:
                        revisar = True
                        break

                if not revisar:
                    continue

                valor = fila_cto[col]
                if pd.isna(valor) or valor is None:
                    continue

                valor_str = str(valor).upper().strip()

                for palabra in PALABRAS_AMBULANCIA_MAESTRA:
                    if palabra in valor_str:
                        return True, col, valor_str

            return False, "", ""

        except Exception as e:
            return False, "", ""

    def obtener_categoria_cuentas_medicas(numero: str, ano: str) -> str:
        try:
            cto_str = f"{str(numero).zfill(4)}-{ano}"

            mask = None
            if COLS.cto:
                mask = df_maestra[COLS.cto] == cto_str

            if mask is None or not mask.any():
                if COLS.numero_contrato and COLS.ano_contrato:
                    mask = (
                        df_maestra[COLS.numero_contrato].astype(str).str.replace('.0', '', regex=False).str.zfill(4) == str(numero).zfill(4)
                    ) & (
                        df_maestra[COLS.ano_contrato].astype(str).str.replace('.0', '', regex=False) == str(ano)
                    )

            if mask is None or not mask.any():
                return ""

            fila_cto = df_maestra[mask].iloc[0]

            for col in df_maestra.columns:
                col_upper = str(col).upper().strip()
                if 'CATEGOR' in col_upper and 'CUENTA' in col_upper:
                    valor = fila_cto[col]
                    if pd.notna(valor):
                        return str(valor).strip()

            return ""
        except:
            return ""

    def agregar_alerta_unica(alerta_dict: dict):
        clave = (alerta_dict['tipo'], alerta_dict['mensaje'], alerta_dict['contrato'], alerta_dict['archivo'])
        if clave not in alertas_set:
            alertas_set.add(clave)
            todas_alertas.append(alerta_dict)

    # ğŸ†• v14.1: RECONECTAR CADA N CONTRATOS
    RECONECTAR_CADA_N = 10

    for idx, contrato in enumerate(CONTRATOS_A_PROCESAR, 1):
        numero, ano = contrato['numero'], contrato['ano']
        id_c = f"{numero}-{ano}"

        LOG.contract_start(idx, len(CONTRATOS_A_PROCESAR), id_c)

        es_ambulancia, col_ambulancia, valor_ambulancia = detectar_ambulancia_en_maestra(numero, ano)
        categoria_cuentas_medicas = obtener_categoria_cuentas_medicas(numero, ano)

        if es_ambulancia:
            LOG.info(f"ğŸ“‹ Contrato identificado como AMBULANCIAS desde maestra")
            LOG.info(f"   Columna: '{col_ambulancia}' â†’ '{valor_ambulancia[:50]}...'")

            agregar_alerta_unica(Alerta(
                tipo=TipoAlerta.CONTRATO_AMBULANCIA_MAESTRA,
                mensaje=f"Identificado como contrato de ambulancias - Columna '{col_ambulancia}' contiene '{valor_ambulancia[:30]}'",
                contrato=id_c
            ).to_dict())

        t_c = time.time()

        # ğŸ†• v14.1: RECONEXIÃ“N FORZADA
        LOG.indent()
        LOG.info("ğŸ”„ Verificando/renovando conexiÃ³n SFTP...")

        conexion_ok = False

        if idx % RECONECTAR_CADA_N == 1 or not cliente.esta_activo():
            LOG.debug(f"ReconexiÃ³n forzada (contrato #{idx})")
            if cliente.reconectar_forzado(silencioso=True):
                conexion_ok = True
                LOG.success("ConexiÃ³n renovada")
            else:
                for intento in range(3):
                    if cliente.conectar(True):
                        conexion_ok = True
                        break
                    LOG.warning(f"Reintento de conexiÃ³n {intento + 1}/3...")
                    time.sleep(2)
        else:
            if cliente.esta_activo():
                conexion_ok = True
            else:
                for intento in range(3):
                    LOG.warning(f"Reconectando (intento {intento + 1})...")
                    if cliente.conectar(True):
                        conexion_ok = True
                        break
                    time.sleep(2)

        if not conexion_ok:
            LOG.error("Sin conexiÃ³n al servidor")
            resumen_contratos.append({
                'contrato': id_c, 'exito': 'NO', 'registros': 0,
                'mensaje': 'Sin conexiÃ³n (Socket closed)', 'tiempo': 0
            })
            agregar_alerta_unica(Alerta(
                tipo=TipoAlerta.CONEXION,
                mensaje='No se pudo conectar - Socket is closed',
                contrato=id_c
            ).to_dict())
            LOG.dedent()
            LOG.contract_end(False, 0, time.time() - t_c, "Sin conexiÃ³n")
            continue

        carpeta = os.path.join(CARPETA_TRABAJO, f"t_{numero}_{ano}")
        os.makedirs(carpeta, exist_ok=True)

        buscador.limpiar_alertas()
        buscador.set_contrato(id_c)
        procesador.limpiar_alertas()
        procesador.set_contrato(id_c)
        procesador.set_categoria_cuentas_medicas(categoria_cuentas_medicas)

        res = {'exito': False, 'archivos': [], 'mensaje': 'Error'}

        for intento in range(3):
            try:
                ok, msg, ruta = buscador.navegar_a_contrato(ano, numero)
                if ok:
                    res = buscador.descargar_anexos(carpeta, id_c)
                else:
                    res = {'exito': False, 'archivos': [], 'mensaje': msg}
                break
            except Exception as e:
                if 'socket' in str(e).lower() and intento < 2:
                    LOG.warning("Error de socket, reconectando...")
                    cliente.reconectar_forzado(silencioso=True)
                else:
                    res['mensaje'] = str(e)[:30]
                    break

        for alerta in buscador.alertas:
            agregar_alerta_unica(alerta.to_dict())

        if not res['exito']:
            resumen_contratos.append({
                'contrato': id_c, 'exito': 'NO', 'registros': 0,
                'mensaje': res['mensaje'], 'tiempo': round(time.time() - t_c, 1)
            })

            try: shutil.rmtree(carpeta)
            except: pass

            LOG.dedent()
            LOG.contract_end(False, 0, time.time() - t_c, res['mensaje'])
            continue

        regs = 0
        es_prob = id_c in CONFIG.CONTRATOS_PROBLEMATICOS
        timeout = CONFIG.TIMEOUT_CONTRATOS_PROBLEMATICOS if es_prob else CONFIG.TIMEOUT_ARCHIVO

        for arch in res['archivos']:
            nombre = arch.nombre if hasattr(arch, 'nombre') else arch.get('nombre', '')
            ruta = arch.ruta_local if hasattr(arch, 'ruta_local') else arch.get('ruta_local', '')
            origen = arch.origen_completo if hasattr(arch, 'origen_completo') else arch.get('origen', '')
            fecha_mod = arch.fecha_modificacion if hasattr(arch, 'fecha_modificacion') else arch.get('fecha_modificacion')

            try:
                ok, servs, msg = procesador.extraer_con_timeout(ruta, nombre, timeout)

                if ok and servs:
                    fecha, f_ok = obtener_fecha_acuerdo(numero, ano, origen, fecha_mod)

                    if f_ok:
                        fechas_ok += 1
                    else:
                        fechas_no += 1
                        contratos_sin_fecha.add(id_c)
                        agregar_alerta_unica(Alerta(
                            tipo=TipoAlerta.FECHA_NO_ENCONTRADA,
                            mensaje=f"Sin fecha para {origen}",
                            contrato=id_c,
                            archivo=nombre
                        ).to_dict())

                    for s in servs:
                        s['contrato'] = id_c
                        s['origen_tarifa'] = origen
                        s['fecha_de_acuerdo'] = fecha if fecha else ''
                        consolidado_total.append(s)

                    regs += len(servs)
                else:
                    archivos_no_positiva.append({
                        'contrato': id_c,
                        'archivo': nombre,
                        'motivo': msg
                    })

            except Exception as e:
                archivos_no_positiva.append({
                    'contrato': id_c,
                    'archivo': nombre,
                    'motivo': str(e)[:50]
                })

        for alerta in procesador.alertas:
            agregar_alerta_unica(alerta.to_dict())

        exito = regs > 0
        resumen_contratos.append({
            'contrato': id_c,
            'exito': 'SI' if exito else 'NO',
            'registros': regs,
            'mensaje': f'{regs} servicios' if exito else 'Sin servicios',
            'tiempo': round(time.time() - t_c, 1),
            'es_ambulancia': 'SI' if es_ambulancia else 'NO'
        })

        try: shutil.rmtree(carpeta)
        except: pass

        LOG.dedent()
        LOG.contract_end(exito, regs, time.time() - t_c, '' if exito else 'Sin servicios')

    LOG.stats_summary()

    print(f"\nğŸ“Š RESUMEN DE PROCESAMIENTO:")
    print(f"   â€¢ Registros consolidados: {len(consolidado_total):,}")
    print(f"   â€¢ Alertas generadas: {len(todas_alertas)} (sin duplicados)")
    print(f"   â€¢ Archivos sin formato POSITIVA: {len(archivos_no_positiva)}")
    print(f"   â€¢ Contratos sin fecha en maestra: {len(contratos_sin_fecha)}")
    print(f"   â€¢ Fechas encontradas: {fechas_ok} | No encontradas: {fechas_no}")
    print(f"   â€¢ Reconexiones SFTP: {cliente.reconexiones}")

    contratos_ambulancia = sum(1 for r in resumen_contratos if r.get('es_ambulancia') == 'SI')
    if contratos_ambulancia > 0:
        print(f"   â€¢ Contratos de ambulancias detectados: {contratos_ambulancia}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CELDA 13: GENERACIÃ“N DE ARCHIVOS v14.1 - ALERTAS SEPARADAS POR HOJAS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

LOG.header("GENERACIÃ“N DE ARCHIVOS v14.1")

archivos_generados = []

sufijos = {
    'ESPECIFICO': f"{CONTRATOS_A_PROCESAR[0]['numero']}_{CONTRATOS_A_PROCESAR[0]['ano']}" if CONTRATOS_A_PROCESAR else 'X',
    'POR_ANO': f"ANO_{CONTRATOS_A_PROCESAR[0]['ano']}" if CONTRATOS_A_PROCESAR else 'X',
    'COMPLETO': 'COMPLETO'
}
suf = sufijos.get(MODO_OPERACION, 'X')
ts = datetime.now().strftime('%Y%m%d_%H%M')

LOG.indent()

if consolidado_total:
    total_registros = len(consolidado_total)
    LOG.info(f"Total de registros a exportar: {total_registros:,}")

    if total_registros > MAX_FILAS_POR_HOJA:
        LOG.warning(f"âš ï¸ El consolidado tiene {total_registros:,} registros")
        LOG.warning(f"   Se dividirÃ¡ en mÃºltiples hojas (mÃ¡x {MAX_FILAS_POR_HOJA:,} por hoja)")

    try:
        df_consolidado = pd.DataFrame(consolidado_total)
        archivo = exportar_consolidado_multisheet(
            df_consolidado,
            f"CONSOLIDADO_{suf}",
            log=LOG
        )
        archivos_generados.append(archivo)
    except Exception as e:
        LOG.error(f"Error exportando consolidado: {str(e)}")
        LOG.info("Intentando exportar a CSV como alternativa...")
        try:
            df_consolidado = pd.DataFrame(consolidado_total)
            archivo_csv = exportar_consolidado_csv(df_consolidado, f"CONSOLIDADO_{suf}", log=LOG)
            archivos_generados.append(archivo_csv)
        except Exception as e2:
            LOG.error(f"Error exportando CSV: {str(e2)}")

# ğŸ†• v14.1: ALERTAS SEPARADAS POR HOJAS
if todas_alertas:
    nombre_alertas = f"ALERTAS_{suf}_{ts}.xlsx"

    try:
        df_alertas = pd.DataFrame(todas_alertas)

        CATEGORIAS_ALERTAS = {
            'CONTRATOS_NO_ENCONTRADOS': [
                'CONTRATO_NO_ENCONTRADO_GO',
                'SIN_CARPETA_TARIFAS',
                'CONEXION'
            ],
            'HOJAS_SIN_SERVICIOS': [
                'HOJA_NO_ENCONTRADA',
                'TARIFA_SERVICIOS_NO_ENCONTRADA',
                'COLUMNAS_NO_DETECTADAS',
                'SEDES_NO_DETECTADAS'
            ],
            'FECHAS_FALTANTES': [
                'FECHA_NO_ENCONTRADA',
                'FECHA_FALTANTE_MAESTRA'
            ],
            'AMBULANCIAS_TRASLADOS': [
                'CONTRATO_AMBULANCIA_MAESTRA',
                'ARCHIVO_SOLO_AMBULANCIAS',
                'ARCHIVO_SOLO_TRASLADOS',
                'SOLO_TRASLADOS',
                'CONTRATO_AMBULANCIA'
            ],
            'ANEXOS_FALTANTES': [
                'SIN_ANEXO1',
                'ACTA_FALTANTE',
                'CARPETA_ACTAS_SIN_ANEXO'
            ],
            # ğŸ†• v15.0: Nueva categorÃ­a para formatos propios
            'FORMATO_PROPIO': [
                'FORMATO_PROPIO',
                'SIN_FORMATO_POSITIVA'
            ],
            'ERRORES_PROCESAMIENTO': [
                'ERROR_PROCESAMIENTO',
                'ERROR_LECTURA',
                'TIMEOUT'
            ]
        }

        with pd.ExcelWriter(nombre_alertas, engine='openpyxl') as writer:
            if 'prioridad' in df_alertas.columns:
                df_alertas_sorted = df_alertas.sort_values(['prioridad', 'tipo', 'contrato'])
            else:
                df_alertas_sorted = df_alertas.sort_values(['tipo', 'contrato'])

            df_alertas_sorted.to_excel(writer, sheet_name='TODAS_ALERTAS', index=False)

            for nombre_hoja, tipos in CATEGORIAS_ALERTAS.items():
                df_categoria = df_alertas[df_alertas['tipo'].isin(tipos)]
                if len(df_categoria) > 0:
                    df_categoria.to_excel(writer, sheet_name=nombre_hoja[:31], index=False)

            todos_tipos_categorizados = [t for tipos in CATEGORIAS_ALERTAS.values() for t in tipos]
            df_otras = df_alertas[~df_alertas['tipo'].isin(todos_tipos_categorizados)]
            if len(df_otras) > 0:
                df_otras.to_excel(writer, sheet_name='OTRAS_ALERTAS', index=False)

        LOG.success(f"Generado: {nombre_alertas}", f"{len(todas_alertas)} alertas en mÃºltiples hojas")
        archivos_generados.append(nombre_alertas)

        print(f"\nğŸ“‹ RESUMEN DE ALERTAS POR CATEGORÃA:")
        for nombre_hoja, tipos in CATEGORIAS_ALERTAS.items():
            count = len(df_alertas[df_alertas['tipo'].isin(tipos)])
            if count > 0:
                print(f"   â€¢ {nombre_hoja}: {count}")

    except Exception as e:
        LOG.error(f"Error generando alertas separadas: {str(e)}")
        df_alertas = pd.DataFrame(todas_alertas)
        if 'prioridad' in df_alertas.columns:
            df_alertas = df_alertas.sort_values(['prioridad', 'tipo', 'contrato'])
        df_alertas.to_excel(nombre_alertas, index=False)
        LOG.warning(f"Generado archivo simple: {nombre_alertas}")
        archivos_generados.append(nombre_alertas)

if resumen_contratos:
    nombre = f"RESUMEN_{suf}_{ts}.xlsx"
    pd.DataFrame(resumen_contratos).to_excel(nombre, index=False)
    LOG.success(f"Generado: {nombre}", f"{len(resumen_contratos)} contratos")
    archivos_generados.append(nombre)

if archivos_no_positiva:
    nombre = f"NO_POSITIVA_{suf}_{ts}.xlsx"
    pd.DataFrame(archivos_no_positiva).to_excel(nombre, index=False)
    LOG.success(f"Generado: {nombre}", f"{len(archivos_no_positiva)} archivos")
    archivos_generados.append(nombre)

LOG.dedent()
LOG.info(f"Total archivos generados: {len(archivos_generados)}")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECCIÃ“N DE TRANSICIÃ“N: CONSOLIDADOR â†’ ETL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\n" + "â•"*70)
print("ğŸ”— INICIANDO TRANSICIÃ“N AL ETL CON MACHINE LEARNING")
print("â•"*70)

# Buscar el archivo CONSOLIDADO generado
archivo_consolidado = None
for archivo in archivos_generados:
    if 'CONSOLIDADO' in archivo.upper() and archivo.endswith('.xlsx'):
        archivo_consolidado = archivo
        break

if archivo_consolidado and os.path.exists(archivo_consolidado):
    print(f"\nâœ… Archivo consolidado encontrado: {archivo_consolidado}")
    print(f"ğŸ“¦ TamaÃ±o: {os.path.getsize(archivo_consolidado)/1024/1024:.2f} MB")

    # Leer el archivo como bytes para el ETL
    with open(archivo_consolidado, 'rb') as f:
        contenido_archivo = f.read()
    nombre_archivo = archivo_consolidado

    print(f"âœ… Archivo cargado en memoria para ETL")
else:
    print("âŒ ERROR: No se encontrÃ³ archivo CONSOLIDADO para procesar")
    print(f"   Archivos disponibles: {archivos_generados}")
    contenido_archivo = None
    nombre_archivo = None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ETL CONSOLIDADOR T25 CON MACHINE LEARNING - INTEGRADO
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#@title 1.2 Importar LibrerÃ­as { display-mode: "form" }

import pandas as pd
import numpy as np
import re
import warnings
import os
import gc
import io
import zipfile
import chardet
from datetime import datetime
from typing import Tuple, Optional, List, Dict, Any
from tqdm.notebook import tqdm
from google.colab import files
from IPython.display import display, HTML

# Machine Learning
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from collections import Counter

# ConfiguraciÃ³n
warnings.filterwarnings('ignore')
pd.set_option('display.max_columns', None)
pd.set_option('display.max_colwidth', 60)
pd.set_option('display.float_format', lambda x: f'{x:,.2f}')

print("="*70)
print("ğŸ§  ETL CONSOLIDADO T25 - EDICIÃ“N MACHINE LEARNING")
print("="*70)
print(f"ğŸ“… {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
print("âœ… LibrerÃ­as cargadas correctamente")

#@title 2.1 Clasificador Inteligente de Texto { display-mode: "form" }

class ClasificadorTextoMedico:
    """
    Clasificador ML para detectar si un texto es:
    - Manual tarifario (SOAT, ISS, PROPIO)
    - DescripciÃ³n de procedimiento mÃ©dico
    - Porcentaje o valor numÃ©rico
    """

    # Vocabulario de referencia para manuales tarifarios
    VOCABULARIO_MANUAL = [
        'SOAT', 'SOAT VIGENTE', 'SOAT UVT', 'SOAT UVB', 'TARIFARIO SOAT',
        'ISS', 'ISS 2001', 'ISS2001', 'TARIFARIOS ISS', 'TARIFA ISS',
        'TARIFA PROPIA', 'TARIFAS PROPIAS', 'PROPIA', 'PROPIO', 'PROPIAS',
        'INSTITUCIONAL', 'TARIFAS INSTITUCIONALES', 'TARIFA INSTITUCIONAL',
        'DECRETO 2423', 'DECRETO 2644', 'UVT', 'UVB', 'TARIFA PLENA',
        'MENOS', 'PLENO', 'VIGENTE', 'MANUAL TARIFARIO'
    ]

    # Vocabulario de procedimientos mÃ©dicos
    VOCABULARIO_MEDICO = [
        'CONSULTA', 'TERAPIA', 'NEURAL', 'CIRUGIA', 'PROCEDIMIENTO',
        'TRATAMIENTO', 'EVALUACION', 'VALORACION', 'DIAGNOSTICO',
        'EXAMEN', 'BIOPSIA', 'ECOGRAFIA', 'RADIOGRAFIA', 'TOMOGRAFIA',
        'RESONANCIA', 'LABORATORIO', 'HEMOGRAMA', 'CURACION', 'SUTURA',
        'INYECCION', 'APLICACION', 'NEBULIZACION', 'HOSPITALIZACION',
        'CONTROL', 'SEGUIMIENTO', 'ESPECIALISTA', 'MEDICINA', 'GENERAL',
        'PEDIATRIA', 'GINECOLOGIA', 'ORTOPEDIA', 'CARDIOLOGIA', 'NEUROLOGIA',
        'PSIQUIATRIA', 'PSICOLOGIA', 'FISIOTERAPIA', 'FONOAUDIOLOGIA',
        'ODONTOLOGIA', 'OPTOMETRIA', 'ANESTESIA', 'URGENCIA', 'AMBULANCIA',
        'SANGRE', 'ORINA', 'GLUCOSA', 'COLESTEROL', 'TRIGLICERIDOS',
        'ELECTROCARDIOGRAMA', 'ENDOSCOPIA', 'COLONOSCOPIA', 'MAMOGRAFIA',
        'QUIMIOTERAPIA', 'RADIOTERAPIA', 'DIALISIS', 'TRASPLANTE', 'PROTESIS',
        'IMPLANTE', 'REHABILITACION', 'TERAPIA OCUPACIONAL', 'TERAPIA FISICA',
        'CONSULTA DE', 'VISITA DE', 'ATENCION DE', 'SERVICIO DE'
    ]

    def __init__(self):
        """Inicializa el clasificador y entrena el vectorizador."""
        # Crear corpus de entrenamiento
        self.corpus_manual = self.VOCABULARIO_MANUAL
        self.corpus_medico = self.VOCABULARIO_MEDICO

        # Entrenar vectorizador TF-IDF
        self.vectorizer = TfidfVectorizer(
            analyzer='char_wb',
            ngram_range=(2, 4),
            lowercase=True,
            max_features=1000
        )

        # Entrenar con todo el vocabulario
        todo_corpus = self.corpus_manual + self.corpus_medico
        self.vectorizer.fit(todo_corpus)

        # Vectores de referencia
        self.vec_manual = self.vectorizer.transform(self.corpus_manual)
        self.vec_medico = self.vectorizer.transform(self.corpus_medico)

        # Centroide de cada clase
        self.centroide_manual = np.asarray(self.vec_manual.mean(axis=0)).flatten()
        self.centroide_medico = np.asarray(self.vec_medico.mean(axis=0)).flatten()

        print("âœ… Clasificador ML entrenado")
        print(f"   â€¢ Vocabulario manual: {len(self.corpus_manual)} tÃ©rminos")
        print(f"   â€¢ Vocabulario mÃ©dico: {len(self.corpus_medico)} tÃ©rminos")

    def clasificar(self, texto: str) -> Dict[str, Any]:
        """
        Clasifica un texto y retorna probabilidades.

        Returns:
            Dict con:
            - 'tipo': 'MANUAL', 'MEDICO', 'PORCENTAJE', 'DESCONOCIDO'
            - 'confianza': 0.0 a 1.0
            - 'scores': diccionario con scores de cada clase
        """
        if pd.isna(texto) or str(texto).strip() == '':
            return {'tipo': 'VACIO', 'confianza': 1.0, 'scores': {}}

        texto = str(texto).strip()
        texto_upper = texto.upper()

        # 1. Reglas rÃ¡pidas basadas en patrones
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        # Es un porcentaje o nÃºmero
        if re.match(r'^[+-]?[\d,\.%\s]+$', texto):
            return {'tipo': 'PORCENTAJE', 'confianza': 0.95, 'scores': {'porcentaje': 0.95}}

        # Contiene palabras clave de manual tarifario
        palabras_manual = ['SOAT', 'ISS', 'TARIFA', 'DECRETO', 'UVT', 'UVB', 'PROPIA', 'PROPIO', 'INSTITUCIONAL']
        for palabra in palabras_manual:
            if palabra in texto_upper:
                return {'tipo': 'MANUAL', 'confianza': 0.9, 'scores': {'manual': 0.9}}

        # Contiene palabras clave mÃ©dicas
        palabras_medicas = ['CONSULTA', 'TERAPIA', 'CIRUGIA', 'PROCEDIMIENTO', 'EXAMEN',
                           'TRATAMIENTO', 'BIOPSIA', 'ECOGRAFIA', 'LABORATORIO']
        for palabra in palabras_medicas:
            if palabra in texto_upper:
                return {'tipo': 'MEDICO', 'confianza': 0.85, 'scores': {'medico': 0.85}}

        # 2. ClasificaciÃ³n ML con TF-IDF
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        try:
            vec_texto = self.vectorizer.transform([texto_upper])
            vec_array = np.asarray(vec_texto.todense()).flatten()

            # Calcular similitud con centroides
            sim_manual = cosine_similarity([vec_array], [self.centroide_manual])[0][0]
            sim_medico = cosine_similarity([vec_array], [self.centroide_medico])[0][0]

            # Normalizar scores
            total = sim_manual + sim_medico + 0.001
            score_manual = sim_manual / total
            score_medico = sim_medico / total

            scores = {'manual': score_manual, 'medico': score_medico}

            if score_manual > score_medico and score_manual > 0.4:
                return {'tipo': 'MANUAL', 'confianza': score_manual, 'scores': scores}
            elif score_medico > score_manual and score_medico > 0.4:
                return {'tipo': 'MEDICO', 'confianza': score_medico, 'scores': scores}
            else:
                return {'tipo': 'DESCONOCIDO', 'confianza': max(score_manual, score_medico), 'scores': scores}

        except Exception as e:
            return {'tipo': 'ERROR', 'confianza': 0.0, 'scores': {}, 'error': str(e)}

    def es_descripcion_medica(self, texto: str) -> Tuple[bool, float]:
        """
        Verifica si un texto parece ser una descripciÃ³n mÃ©dica.

        Returns:
            (es_medico, confianza)
        """
        resultado = self.clasificar(texto)
        return resultado['tipo'] == 'MEDICO', resultado['confianza']

    def es_manual_tarifario(self, texto: str) -> Tuple[bool, float]:
        """
        Verifica si un texto parece ser un manual tarifario vÃ¡lido.

        Returns:
            (es_manual, confianza)
        """
        resultado = self.clasificar(texto)
        return resultado['tipo'] == 'MANUAL', resultado['confianza']


# Crear instancia global
clasificador_ml = ClasificadorTextoMedico()

#@title 2.2 Probar el Clasificador ML { display-mode: "form" }
#@markdown ### ğŸ§ª **Prueba el clasificador con ejemplos**

print("="*70)
print("ğŸ§ª PRUEBAS DEL CLASIFICADOR ML")
print("="*70)

# Ejemplos de prueba
ejemplos = [
    # Manuales tarifarios
    "SOAT VIGENTE",
    "TARIFA PROPIA",
    "ISS 2001 + 80%",
    "DECRETO 2644 UVT",
    "TARIFAS INSTITUCIONALES",

    # Descripciones mÃ©dicas
    "CONSULTA DE MEDICINA GENERAL",
    "TERAPIA NEURAL POR SESION",
    "CIRUGIA DE RODILLA",
    "ECOGRAFIA ABDOMINAL",
    "LABORATORIO HEMOGRAMA",

    # Porcentajes
    "-30%",
    "0.05",
    "ISS + 65%",

    # Casos ambiguos
    "CONSULTA",
    "PROPIA",
    "VALORACION"
]

print(f"\n{'Texto':<45} {'Tipo':<12} {'Confianza':<10}")
print("â”€"*70)

for ejemplo in ejemplos:
    resultado = clasificador_ml.clasificar(ejemplo)
    print(f"{ejemplo:<45} {resultado['tipo']:<12} {resultado['confianza']:.2f}")

#@title 3.1 Clase ETL con Machine Learning { display-mode: "form" }

class ETLConsolidadoT25_ML:
    """
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    ETL CONSOLIDADO T25 - VERSIÃ“N CON MACHINE LEARNING
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    Sistema inteligente que detecta y corrige automÃ¡ticamente cuando:
    - manual_tarifario contiene descripciones mÃ©dicas
    - porcentaje_manual_tarifario contiene el manual real
    - Los valores estÃ¡n intercambiados entre columnas
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    """

    ANOS_IGNORAR = {'1996', '2001', '2016', '2022', '2023', '2024', '2025', '2644', '2423', '780'}

    PATRON_NUMERO = re.compile(r'[+-]?\d+(?:[,\.]\d+)?')
    PATRON_PORCENTAJE_FINAL = re.compile(r'[+-]\s*(\d+(?:[,\.]\d+)?)\s*$')
    PATRON_MENOS = re.compile(r'MENOS\s*(\d+(?:[,\.]\d+)?)', re.IGNORECASE)
    PATRON_MAS = re.compile(r'(?:MAS|\+)\s*(\d+(?:[,\.]\d+)?)', re.IGNORECASE)
    PATRON_DECIMAL = re.compile(r'^(-?0\.\d+)$')

    def __init__(self, clasificador: ClasificadorTextoMedico, chunk_size: int = 50000):
        """Inicializa el ETL con el clasificador ML."""
        self.clasificador = clasificador
        self.chunk_size = chunk_size
        self.stats = {
            'total_registros': 0,
            'columnas_intercambiadas': 0,
            'manuales_normalizados': 0,
            'porcentajes_extraidos': 0,
            'anomalias_detectadas': [],
            'correcciones_ml': []
        }
        self.resultados = {}

    def _detectar_y_corregir_anomalia(self, row: pd.Series) -> Dict[str, Any]:
        """
        Detecta si hay anomalÃ­a en la fila y sugiere correcciÃ³n.

        AnomalÃ­as detectadas:
        1. manual_tarifario tiene descripciÃ³n mÃ©dica
        2. porcentaje_manual_tarifario tiene el manual real
        3. Valores intercambiados

        Returns:
            Dict con correcciones sugeridas
        """
        manual = str(row.get('manual_tarifario', '')).strip()
        porcentaje = str(row.get('porcentaje_manual_tarifario', '')).strip()
        descripcion = str(row.get('descripcion_del_cups', '')).strip()

        correccion = {
            'necesita_correccion': False,
            'nuevo_manual': manual,
            'nuevo_porcentaje': porcentaje,
            'razon': None,
            'confianza': 0.0
        }

        if not manual:
            return correccion

        # Clasificar el contenido de manual_tarifario
        clasif_manual = self.clasificador.clasificar(manual)
        clasif_porcentaje = self.clasificador.clasificar(porcentaje)

        # CASO 1: manual_tarifario tiene descripciÃ³n mÃ©dica
        if clasif_manual['tipo'] == 'MEDICO' and clasif_manual['confianza'] > 0.6:
            # Verificar si porcentaje tiene el manual real
            if clasif_porcentaje['tipo'] == 'MANUAL' and clasif_porcentaje['confianza'] > 0.5:
                correccion['necesita_correccion'] = True
                correccion['nuevo_manual'] = porcentaje
                correccion['nuevo_porcentaje'] = '0'  # Extraer del nuevo manual si hay
                correccion['razon'] = f"ML detectÃ³ descripciÃ³n mÃ©dica en manual_tarifario (conf: {clasif_manual['confianza']:.2f})"
                correccion['confianza'] = clasif_manual['confianza']
                return correccion

        # CASO 2: manual_tarifario es similar a descripcion_del_cups
        if descripcion and len(manual) > 20:
            manual_words = set(manual.upper().split())
            desc_words = set(descripcion.upper().split())
            if len(manual_words) > 0 and len(desc_words) > 0:
                similitud = len(manual_words & desc_words) / min(len(manual_words), len(desc_words))
                if similitud > 0.5:  # MÃ¡s del 50% de palabras en comÃºn
                    if clasif_porcentaje['tipo'] == 'MANUAL':
                        correccion['necesita_correccion'] = True
                        correccion['nuevo_manual'] = porcentaje
                        correccion['nuevo_porcentaje'] = '0'
                        correccion['razon'] = f"manual_tarifario similar a descripciÃ³n ({similitud:.0%})"
                        correccion['confianza'] = similitud
                        return correccion

        # CASO 3: manual_tarifario tiene formato de tarifa (nÃºmero grande)
        try:
            valor_manual = float(manual.replace(',', '.').replace('$', '').strip())
            if valor_manual > 1000:  # Parece una tarifa, no un manual
                if clasif_porcentaje['tipo'] == 'MANUAL':
                    correccion['necesita_correccion'] = True
                    correccion['nuevo_manual'] = porcentaje
                    correccion['nuevo_porcentaje'] = '0'
                    correccion['razon'] = f"manual_tarifario contiene tarifa ({valor_manual:,.0f})"
                    correccion['confianza'] = 0.9
                    return correccion
        except:
            pass

        return correccion

    def _extraer_porcentaje(self, texto: str) -> Optional[float]:
        """Extrae porcentaje de forma inteligente."""
        if pd.isna(texto) or str(texto).strip() == '':
            return None

        texto = str(texto).strip()
        texto_upper = texto.upper()

        if 'PLENA' in texto_upper or 'PLENO' in texto_upper:
            if not re.search(r'[+-]\s*\d+', texto_upper):
                return 0.0

        texto_sin_pct = texto.replace('%', '')

        match = self.PATRON_PORCENTAJE_FINAL.search(texto_sin_pct)
        if match:
            try:
                valor = float(match.group(1).replace(',', '.'))
                if '-' in texto_sin_pct:
                    valor = -abs(valor)
                if -100 <= valor <= 200:
                    return valor
            except:
                pass

        match = self.PATRON_MENOS.search(texto_sin_pct)
        if match:
            try:
                return -float(match.group(1).replace(',', '.'))
            except:
                pass

        match = self.PATRON_MAS.search(texto_sin_pct)
        if match:
            try:
                return float(match.group(1).replace(',', '.'))
            except:
                pass

        match = self.PATRON_DECIMAL.match(texto_sin_pct.strip())
        if match:
            try:
                return round(float(match.group(1)) * 100, 2)
            except:
                pass

        numeros = self.PATRON_NUMERO.findall(texto_sin_pct)
        for num_str in reversed(numeros):
            try:
                num = float(num_str.replace(',', '.'))
                if str(int(abs(num))) in self.ANOS_IGNORAR:
                    continue
                if num > 1000:
                    continue
                if -100 <= num <= 200:
                    if 'MENOS' in texto_upper or f'-{num_str}' in texto:
                        num = -abs(num)
                    return num
            except:
                continue

        return None

    def _normalizar_manual(self, texto: str) -> str:
        """Normaliza el manual tarifario."""
        if pd.isna(texto) or str(texto).strip() == '':
            return 'PROPIO'

        texto = str(texto).strip()
        texto_upper = texto.upper()

        # PROPIO
        if re.search(r'\bPROPIA?S?\b|INSTITUCIONAL|TARIA\s*PROPIA', texto_upper):
            return 'PROPIO'

        # ISS
        if re.search(r'\bISS\b', texto_upper) and not re.search(r'\bSOAT\b', texto_upper):
            return 'ISS'

        # SOAT
        if re.search(r'\bSOAT\b|\bUVT\b|\bUVB\b|DECRETO\s*2423|DECRETO\s*2644', texto_upper):
            return 'SOAT'

        # NÃºmeros puros -> PROPIO
        if re.match(r'^[\d,\.\s]+$', texto):
            return 'PROPIO'

        return texto

    def _procesar_fila(self, row: pd.Series) -> Dict[str, Any]:
        """
        Procesa una fila completa con detecciÃ³n ML.
        """
        resultado = {
            'manual_tarifario': '',
            'porcentaje_manual_tarifario': 0.0,
            'correccion_aplicada': False,
            'log': None
        }

        # 1. Detectar anomalÃ­as
        correccion = self._detectar_y_corregir_anomalia(row)

        if correccion['necesita_correccion']:
            # Usar valores corregidos
            manual_raw = correccion['nuevo_manual']
            porcentaje_raw = correccion['nuevo_porcentaje']
            resultado['correccion_aplicada'] = True
            resultado['log'] = correccion['razon']
        else:
            manual_raw = str(row.get('manual_tarifario', '')).strip()
            porcentaje_raw = str(row.get('porcentaje_manual_tarifario', '')).strip()

        # 2. Normalizar manual
        resultado['manual_tarifario'] = self._normalizar_manual(manual_raw)

        # 3. Extraer porcentaje
        tarifa = row.get('tarifa_unitaria_en_pesos', '0')
        try:
            tarifa_num = float(str(tarifa).replace(',', '.'))
        except:
            tarifa_num = 0

        # Si porcentaje es texto de manual o propio -> 0
        porcentaje_upper = porcentaje_raw.upper()
        if any(p in porcentaje_upper for p in ['PROPIO', 'PROPIA', 'INSTITUCIONAL', 'PLENA', 'PLENO']):
            resultado['porcentaje_manual_tarifario'] = 0.0
        else:
            # Extraer porcentaje
            pct = self._extraer_porcentaje(porcentaje_raw)
            if pct is not None:
                # Verificar que no sea igual a la tarifa
                if tarifa_num > 0 and abs(pct - tarifa_num) < 1:
                    resultado['porcentaje_manual_tarifario'] = 0.0
                elif pct > 1000:  # Probable tarifa duplicada
                    resultado['porcentaje_manual_tarifario'] = 0.0
                else:
                    resultado['porcentaje_manual_tarifario'] = round(pct, 2)
            else:
                resultado['porcentaje_manual_tarifario'] = 0.0

        return resultado

    def procesar_dataframe(self, df: pd.DataFrame, nombre: str = "Datos") -> pd.DataFrame:
        """Procesa un DataFrame completo."""
        print(f"\n{'â•'*70}")
        print(f"ğŸ§  PROCESANDO CON ML: {nombre}")
        print(f"{'â•'*70}")

        inicio = datetime.now()
        total = len(df)
        print(f"ğŸ“Š Total registros: {total:,}")

        # Normalizar columnas
        df.columns = df.columns.str.strip().str.lower().str.replace(' ', '_')

        # Asegurar columnas
        for col in ['manual_tarifario', 'porcentaje_manual_tarifario', 'tarifa_unitaria_en_pesos']:
            if col not in df.columns:
                df[col] = ''

        # Procesar
        print(f"\nğŸ”„ Fase 1: DetecciÃ³n de anomalÃ­as con ML...")

        nuevos_manuales = []
        nuevos_porcentajes = []
        correcciones = []

        for idx in tqdm(range(total), desc="   Procesando"):
            row = df.iloc[idx]
            resultado = self._procesar_fila(row)

            nuevos_manuales.append(resultado['manual_tarifario'])
            nuevos_porcentajes.append(resultado['porcentaje_manual_tarifario'])

            if resultado['correccion_aplicada']:
                correcciones.append({
                    'indice': idx,
                    'original_manual': row.get('manual_tarifario', ''),
                    'original_porcentaje': row.get('porcentaje_manual_tarifario', ''),
                    'nuevo_manual': resultado['manual_tarifario'],
                    'log': resultado['log']
                })

        df['manual_tarifario'] = nuevos_manuales
        df['porcentaje_manual_tarifario'] = nuevos_porcentajes

        # Corregir tarifas
        print(f"\nğŸ”„ Fase 2: Corrigiendo tarifas...")
        tarifa = pd.to_numeric(
            df['tarifa_unitaria_en_pesos'].astype(str).str.replace(',', '.'),
            errors='coerce'
        ).fillna(0)
        mask_pequena = (tarifa > 0) & (tarifa < 100)
        tarifa.loc[mask_pequena] = tarifa.loc[mask_pequena] * 1000
        df['tarifa_unitaria_en_pesos'] = tarifa.round(2)

        # EstadÃ­sticas
        duracion = (datetime.now() - inicio).total_seconds()

        print(f"\n{'â”€'*70}")
        print(f"ğŸ“ˆ RESULTADOS - {nombre}")
        print(f"{'â”€'*70}")
        print(f"â±ï¸ Tiempo: {duracion:.1f} segundos")
        print(f"ğŸ”§ Correcciones ML aplicadas: {len(correcciones):,}")

        if correcciones:
            print(f"\nğŸ“ Muestra de correcciones aplicadas:")
            for c in correcciones[:10]:
                print(f"   â€¢ Fila {c['indice']}: {c['log']}")
                print(f"     Original: '{str(c['original_manual'])[:40]}...'")
                print(f"     Corregido: '{c['nuevo_manual']}'")

        print(f"\nğŸ“Š DistribuciÃ³n de Manuales:")
        for manual, count in df['manual_tarifario'].value_counts().head(10).items():
            pct = count / total * 100
            print(f"   {manual:15} â”‚ {count:>10,} â”‚ {pct:5.1f}%")

        self.stats['total_registros'] += total
        self.stats['columnas_intercambiadas'] += len(correcciones)
        self.stats['correcciones_ml'].extend(correcciones)

        gc.collect()
        return df

    def ejecutar(self, contenido: bytes, nombre: str) -> Dict[str, pd.DataFrame]:
        """Ejecuta el ETL completo."""
        print("\n" + "â•"*70)
        print("ğŸš€ ETL CONSOLIDADO T25 - ML EDITION")
        print("â•"*70)
        print(f"ğŸ“ Archivo: {nombre}")
        print(f"ğŸ“… {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

        inicio = datetime.now()

        # Cargar archivo
        dataframes = self._cargar_archivo(contenido, nombre)

        # Procesar cada hoja
        for nombre_hoja, df in dataframes.items():
            self.resultados[nombre_hoja] = self.procesar_dataframe(df, nombre_hoja)

        duracion = (datetime.now() - inicio).total_seconds()

        print("\n" + "â•"*70)
        print("âœ… ETL ML COMPLETADO")
        print("â•"*70)
        print(f"ğŸ“Š Total registros: {self.stats['total_registros']:,}")
        print(f"ğŸ”§ Correcciones ML: {self.stats['columnas_intercambiadas']:,}")
        print(f"â±ï¸ Tiempo: {duracion:.1f} segundos")

        return self.resultados

    def _cargar_archivo(self, contenido: bytes, nombre: str) -> Dict[str, pd.DataFrame]:
        """Carga archivo Excel o CSV."""
        dataframes = {}

        if nombre.endswith('.csv'):
            resultado = chardet.detect(contenido[:10000])
            encoding = resultado['encoding'] or 'utf-8'

            for sep in [';', ',', '\t']:
                try:
                    df = pd.read_csv(io.BytesIO(contenido), sep=sep, encoding=encoding,
                                    dtype=str, low_memory=False)
                    if len(df.columns) > 1:
                        dataframes['Datos'] = df
                        break
                except:
                    continue
        else:
            excel = pd.ExcelFile(io.BytesIO(contenido))
            for hoja in excel.sheet_names:
                df = pd.read_excel(excel, sheet_name=hoja, dtype=str)
                if len(df) > 0:
                    dataframes[hoja] = df

        return dataframes

    def exportar_log_correcciones(self, archivo: str = 'correcciones_ml.csv'):
        """Exporta log de correcciones ML."""
        if self.stats['correcciones_ml']:
            df_log = pd.DataFrame(self.stats['correcciones_ml'])
            df_log.to_csv(archivo, index=False, encoding='utf-8-sig')
            print(f"âœ… Log exportado: {archivo}")
            return df_log
        else:
            print("â„¹ï¸ No hay correcciones ML para exportar")
            return None


print("âœ… Clase ETLConsolidadoT25_ML definida")

#@title 4.2 Ejecutar ETL con Machine Learning { display-mode: "form" }
#@markdown ### âš™ï¸ **Procesa el archivo con detecciÃ³n inteligente de anomalÃ­as**

if 'contenido_archivo' not in dir() or contenido_archivo is None:
    print("âŒ ERROR: No hay archivo para procesar")
    print("   Verifica que el consolidador haya generado el archivo CONSOLIDADO")
else:
    # Crear ETL con clasificador ML
    etl_ml = ETLConsolidadoT25_ML(
        clasificador=clasificador_ml,
        chunk_size=50000
    )

    # Ejecutar
    dataframes_limpios = etl_ml.ejecutar(contenido_archivo, nombre_archivo)

    print("\nğŸ“¦ DataFrames disponibles en: dataframes_limpios")

#@title 5.1 Ver Correcciones ML Aplicadas { display-mode: "form" }
#@markdown ### ğŸ”§ **Muestra las correcciones detectadas por ML**

if 'etl_ml' not in dir():
    print("âŒ ERROR: Primero ejecuta el ETL")
else:
    correcciones = etl_ml.stats['correcciones_ml']

    print("="*70)
    print("ğŸ”§ CORRECCIONES ML APLICADAS")
    print("="*70)
    print(f"\nğŸ“Š Total correcciones: {len(correcciones):,}")

    if correcciones:
        print(f"\nğŸ“ Detalle de correcciones:")
        print("â”€"*70)

        for i, c in enumerate(correcciones[:50]):
            print(f"\n[{i+1}] Fila {c['indice']}")
            print(f"    ğŸ“Œ RazÃ³n: {c['log']}")
            print(f"    âŒ Original manual: {str(c['original_manual'])[:60]}")
            print(f"    âŒ Original %: {str(c['original_porcentaje'])[:40]}")
            print(f"    âœ… Nuevo manual: {c['nuevo_manual']}")

        if len(correcciones) > 50:
            print(f"\n... y {len(correcciones) - 50} correcciones mÃ¡s")
    else:
        print("\nâœ… No se detectaron anomalÃ­as que requieran correcciÃ³n ML")

#@title 5.2 Ver Resumen de Resultados { display-mode: "form" }

if 'dataframes_limpios' not in dir():
    print("âŒ ERROR: Primero ejecuta el ETL")
else:
    print("="*70)
    print("ğŸ“Š RESUMEN DE RESULTADOS")
    print("="*70)

    for nombre, df in dataframes_limpios.items():
        print(f"\n{'â”€'*70}")
        print(f"ğŸ“‘ {nombre}: {len(df):,} registros")
        print(f"{'â”€'*70}")

        print(f"\nğŸ“‹ Manuales Tarifarios:")
        for val, count in df['manual_tarifario'].value_counts().items():
            pct = count / len(df) * 100
            barra = 'â–ˆ' * int(pct / 2)
            print(f"   {val:15} â”‚ {count:>10,} â”‚ {pct:5.1f}% â”‚ {barra}")

        print(f"\nğŸ“Š Top 10 Porcentajes:")
        for val, count in df['porcentaje_manual_tarifario'].value_counts().head(10).items():
            print(f"   {str(val):>10}% : {count:>10,}")

#@title 5.3 Ver Muestra de Datos { display-mode: "form" }

#@markdown Filas a mostrar:
n_filas = 25 #@param {type:"slider", min:5, max:100, step:5}

if 'dataframes_limpios' not in dir():
    print("âŒ ERROR: Primero ejecuta el ETL")
else:
    for nombre, df in dataframes_limpios.items():
        print(f"\n{'â•'*70}")
        print(f"ğŸ“‘ MUESTRA: {nombre}")
        print(f"{'â•'*70}")

        cols = ['codigo_cups', 'descripcion_del_cups', 'tarifa_unitaria_en_pesos',
                'manual_tarifario', 'porcentaje_manual_tarifario', 'contrato']
        cols_disp = [c for c in cols if c in df.columns]

        display(df[cols_disp].head(n_filas))

#@title 6.1 Exportar a Excel { display-mode: "form" }

if 'dataframes_limpios' not in dir():
    print("âŒ ERROR: Primero ejecuta el ETL")
else:
    print("="*70)
    print("ğŸ’¾ EXPORTANDO A EXCEL")
    print("="*70)

    nombre_base = nombre_archivo.rsplit('.', 1)[0]
    archivo_excel = f"{nombre_base}_ML_LIMPIO.xlsx"

    print(f"\nğŸ“ Generando: {archivo_excel}")

    with pd.ExcelWriter(archivo_excel, engine='xlsxwriter') as writer:
        workbook = writer.book

        fmt_header = workbook.add_format({
            'bold': True, 'bg_color': '#6A1B9A', 'font_color': 'white',
            'align': 'center', 'border': 1
        })
        fmt_moneda = workbook.add_format({'num_format': '$#,##0.00'})

        for nombre_hoja, df in tqdm(dataframes_limpios.items(), desc="Exportando"):
            hoja = nombre_hoja[:31]
            df.to_excel(writer, sheet_name=hoja, index=False, startrow=1, header=False)

            ws = writer.sheets[hoja]
            for col, column in enumerate(df.columns):
                ws.write(0, col, column, fmt_header)
                if column == 'tarifa_unitaria_en_pesos':
                    ws.set_column(col, col, 20, fmt_moneda)
                else:
                    ws.set_column(col, col, 15)

            ws.freeze_panes(1, 0)
            ws.autofilter(0, 0, len(df), len(df.columns) - 1)

    print(f"\nâœ… Excel generado: {archivo_excel}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DESCARGA DE TODOS LOS ARCHIVOS (CONSOLIDADOR + ETL)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

LOG.header("DESCARGA DE ARCHIVOS FINALES")

# Agregar archivos del ETL a la lista de archivos generados
if 'archivo_excel' in dir() and os.path.exists(archivo_excel):
    archivos_generados.append(archivo_excel)

if os.path.exists('correcciones_ml.csv'):
    archivos_generados.append('correcciones_ml.csv')

# Descargar todos los archivos
if archivos_generados:
    LOG.indent()
    print(f"\nğŸ“¦ Total de archivos a descargar: {len(archivos_generados)}")
    for archivo in archivos_generados:
        if os.path.exists(archivo):
            size_kb = os.path.getsize(archivo) / 1024
            LOG.download(archivo, f"{size_kb:.1f} KB")
            files.download(archivo)
    LOG.dedent()

    LOG.success("Descarga completada")
else:
    LOG.warning("No hay archivos para descargar")

# Cerrar conexiÃ³n SFTP
try:
    cliente.desconectar()
except:
    pass

print("\n" + "â•"*70)
print("âœ… CONSOLIDADOR T25 + ETL ML - PROCESO COMPLETO FINALIZADO")
print("â•"*70)
print("""
ğŸ“‹ ARCHIVOS GENERADOS:
   â€¢ CONSOLIDADO_*.xlsx    - Datos consolidados del GoAnywhere
   â€¢ *_ML_LIMPIO.xlsx      - Datos procesados con ML
   â€¢ ALERTAS_*.xlsx        - Alertas del procesamiento
   â€¢ RESUMEN_*.xlsx        - Resumen de contratos
   â€¢ correcciones_ml.csv   - Log de correcciones ML (si aplica)

ğŸ’¡ EL PROCESO SE EJECUTÃ“ DE FORMA AUTOMÃTICA:
   1. Consolidador T25 â†’ Extrae datos de GoAnywhere
   2. ETL con ML â†’ Limpia y normaliza los datos
   3. Descarga â†’ Todos los archivos disponibles
""")
